<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>GooFit: documentation.md Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">GooFit
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">documentation.md</div>  </div>
</div><!--header-->
<div class="contents">
<a href="documentation_8md.html">Go to the documentation of this file.</a><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;The GooFit Framework {#mainpage}</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;================================</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;Introduction</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;============</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;[GooFit](https://github.com/GooFit/GooFit) (\ref footnote1 &quot;1&quot;)</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;is a framework for creating arbitrary probability density</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;functions (PDFs) and evaluating them over large datasets using nVidia</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;Graphics Processing Units (GPUs). New PDFs are written partly in</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;nVidia’s CUDA programming language and partly in C++; however, no</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;expertise in CUDA is required to get started, because the</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;already-existing PDFs can be put together in plain C++.</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;Aside from the mass of unenlightened hominids who have not yet</div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;discovered their need for a massively-parallel fitting framework, there</div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;are three kinds of GooFit users:</div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;</div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;-   Initiates, who write “user-level code” - that is, code which</div><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;    instantiates existing PDF classes in some combination. No knowledge</div><div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;    of CUDA is required for this level. If your data can be described by</div><div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;    a combination of not-too-esoteric functions, even if the combination</div><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;    is complicated, then user code is sufficient. Section</div><div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;    [User code](@ref usercode) gives an example of how to write a simple fit.</div><div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;</div><div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;-   Acolytes, or advanced users, who have grasped the art of creating</div><div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;    new PDF classes. This involves some use of CUDA, but is mainly a</div><div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;    question of understanding the variable-index organisation that</div><div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;    GooFit PDFs use. Section [New PDFs](@ref newpdfs) considers this organisation</div><div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;    in some depth.</div><div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;</div><div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;-   Ascended Masters, or architects, who by extended meditation have</div><div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;    acquired a full understanding of the core engine of GooFit, and can</div><div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;    modify it to their desire (\ref footnote2 &quot;2&quot;). Section [Engine](@ref engine) gives a</div><div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;    detailed narrative of the progress of a PDF evaluation through the</div><div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;    engine core, thus elucidating its mysteries. It should only rarely</div><div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;    be necessary to acquire this level of mastery; in principle only the</div><div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;    developers of GooFit need to know its internal details.</div><div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;</div><div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;Aside from considerations of the user’s understanding, GooFit does</div><div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;require a CUDA-capable graphics card to run on, with compute capability</div><div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;at least 2.1. Further, you will need nVidia’s CUDA SDK, in particular</div><div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;the `nvcc` compiler. Aside from this, GooFit is known to compile and run</div><div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;on Fedora 14, Ubuntu 12.04, and OSX 10.8.4. It has been tested on the</div><div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;Tesla, Fermi, and Kepler generations of nVidia GPUs.</div><div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;</div><div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;Getting started</div><div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;---------------</div><div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;</div><div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;You will need to have a CUDA-capable device and to have the development</div><div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;environment (also known as the software development kit or SDK) set up,</div><div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;with access to the compiler `nvcc` and its libraries. If you have the</div><div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;hardware, you can get the SDK from [nVidia’s</div><div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;website](https://developer.nvidia.com/gpu-computing-sdk).</div><div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;</div><div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;With your CUDA environment set up, you can install GooFit thus:</div><div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;</div><div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;-   Clone from the GitHub repository:</div><div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;</div><div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;        git clone git://github.com/GooFit/GooFit.git</div><div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;        cd GooFit</div><div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;</div><div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;-   Compile with `cmake`:</div><div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;</div><div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;        mkdir build</div><div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;        cd build</div><div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;        cmake ..</div><div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;        make</div><div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;</div><div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;    Do not be alarmed by warning</div><div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;    messages saying that such-and-such a function’s stack size could not</div><div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;    be statically determined; this is an unavoidable (so far) side</div><div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;    effect of the function-pointer implementation discussed in section</div><div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;    [Engine](@ref engine).</div><div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;</div><div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;-   Run the ‘simpleFitExample’ program, which generates</div><div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;    three distributions, fits them, and plots the results:</div><div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;</div><div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;        cd examples/simpleFit</div><div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;        ./simpleFit</div><div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;</div><div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;    The expected output is a MINUIT log for three different fits, and</div><div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;    three image files.</div><div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;</div><div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;-   Run the Dalitz-plot tutorial, which fits a text file</div><div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;    containing toy Monte Carlo data to a coherent sum of Breit-Wigner</div><div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;    resonances:</div><div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;</div><div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;        cd examples/dalitz</div><div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;        ./dalitz dalitz_toyMC_000.txt</div><div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;</div><div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;Quick troubleshooting: GooFit uses [FindCUDA](https://cmake.org/cmake/help/v3.7/module/FindCUDA.html), and expects</div><div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;to find `root-config` in your path. Check the docs for FindCUDA if you need help locating your CUDA install.</div><div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;</div><div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;The text file contains information about simulated decays of the \f$D^0\f$</div><div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;particle to \f$\pi^+\pi^-\pi^0\f$; in particular, in each line, the second</div><div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;and third numbers are the Dalitz-plot coordinates \f$m^2(pi^+\pi^0)\f$ and</div><div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;\f$m^2(pi^-\pi^0)\f$. The `dalitz` program creates a PDF describing the</div><div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;distribution of these two variables in terms of Breit-Wigner resonances,</div><div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;reads the data, sends it to the GPU, and fits the PDF to the data - the</div><div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;floating parameters are the complex coefficients of the resonances. The</div><div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;expected output is a MINUIT fit log showing that the fit converged, with</div><div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;such-and-such values for the real and imaginary parts of the resonance</div><div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;coefficients.</div><div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;</div><div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;User-level code {#usercode}</div><div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;===============</div><div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;</div><div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;From the outside, GooFit code should look like ordinary, object-oriented</div><div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;C++ code: The CUDA parts are hidden away inside the engine, invisible to</div><div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;the user. Thus, to construct a simple Gaussian fit, merely declare three</div><div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;`Variable` objects and a `GaussianPdf` object that uses them, and create</div><div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;an appropriate `UnbinnedDataSet` to fit to:</div><div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;</div><div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;</div><div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;Simple Gaussian fit {#listinggaussfit} </div><div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;-------------------</div><div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;</div><div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;```{.cpp}</div><div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;int main (int argc, char** argv) {</div><div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;</div><div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;  // Optional, but highly recommended. Based loosly on TApplication.</div><div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;  GooFit::Application app {&quot;Simple Gaussian Fit&quot;, argc, argv};</div><div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;</div><div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;  // Run the application parser, setup MPI if needed, and exit if parsing failed</div><div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;  try {</div><div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;      app.run();</div><div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;  } catch (const GooFit::ParseError&amp; e) {</div><div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;      return app.exit(e);</div><div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;  }</div><div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;</div><div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;</div><div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;  // Create an object to represent the observable, </div><div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;  // the number we have measured. Give it a name,</div><div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;  // upper and lower bounds, and a number of bins</div><div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;  // to use in numerical integration. </div><div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;  Variable xvar {&quot;xvar&quot;, -5, 5}; </div><div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;  xvar.setNumBins(1000); </div><div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;</div><div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;  // A data set to store our observations in.</div><div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;  UnbinnedDataSet data {xvar};</div><div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;</div><div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;  // &quot;Observe&quot; ten thousand events and add them</div><div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;  // to the data set, throwing out any events outside</div><div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;  // the allowed range. In a real fit this step would</div><div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;  // involve reading a previously created file of data</div><div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;  // from an _actual_ experiment. </div><div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;  TRandom donram(42); </div><div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;  for (int i = 0; i &lt; 10000; ++i) {</div><div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;    fptype val = donram.Gaus(0.2, 1.1);</div><div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;    if (fabs(val) &gt; 5) {--i; continue;} </div><div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;    data.addEvent(val); </div><div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;  }</div><div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;</div><div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;  // Variables to represent the mean and standard deviation</div><div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;  // of the Gaussian PDF we&#39;re going to fit to the data.</div><div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;  // They take a name, starting value, optional initial </div><div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;  // step size and upper and lower bounds. Notice that</div><div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;  // here only the mean is given a step size; the sigma</div><div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;  // will use the default step of one-tenth of its range.</div><div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;  Variable mean {&quot;mean&quot;, 0, 1, -10, 10};</div><div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;  Variable sigm {&quot;sigm&quot;, 1, 0.5, 1.5}; </div><div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;</div><div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;  // The actual PDF. The Gaussian takes a name, an independent</div><div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;  // (ie observed) variable, and a mean and width. </div><div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;  GaussianPdf gauss {&quot;gauss&quot;, &amp;xvar, &amp;mean, &amp;sigm}; </div><div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;</div><div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;  // Copy the data to the GPU. </div><div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;  gauss.setData(&amp;data);</div><div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;</div><div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;  // A class that talks to MINUIT and GooFit. It needs</div><div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;  // to know what PDF it should set up in MINUIT. </div><div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;  FitManager fitter {&amp;gauss}; </div><div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;</div><div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;  // The actual fit. </div><div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;  fitter.fit();</div><div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;  return 0;</div><div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;}</div><div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;```</div><div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;</div><div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;Notice that, behind the scenes, GooFit assumes that there will be</div><div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;exactly one top-level PDF and data set; it is not advised to break this</div><div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;assumption unless you know what you are doing and exactly how you are</div><div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;getting around it.</div><div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;</div><div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;Data sets</div><div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;---------</div><div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;</div><div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;To create a data set with several dimensions, supply a `vector` of</div><div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;`Variables`:</div><div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;</div><div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;```{.cpp}</div><div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;vector&lt;Variable*&gt; vars;</div><div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;Variable xvar {&quot;xvar&quot;, -10, 10};</div><div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;Variable yvar {&quot;yvar&quot;, -10, 10};</div><div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;vars.push_back(&amp;xvar);</div><div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;vars.push_back(&amp;yvar);</div><div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;UnbinnedDataSet data(vars);</div><div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;```</div><div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;</div><div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;In this case, to fill the data set, set the `Variable` values and call</div><div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;the `addEvent` method without arguments:</div><div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;</div><div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;```{.cpp}</div><div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;xvar.setValue(3);</div><div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;yvar.setValue(-2);</div><div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;data.addEvent();</div><div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;```</div><div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;</div><div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;This will add an event with the current values of the `Variable` list to</div><div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;the data set. In general, where an unknown number of arguments are</div><div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;wanted, GooFit prefers to use a `vector` of pointers.</div><div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;</div><div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;Fit types</div><div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;---------</div><div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;</div><div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;By default, GooFit will do an unbinned maximum-likelihood fit, where the</div><div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;goodness-of-fit metric that is minimised (\ref footnote3 &quot;3&quot;) is the negative sum of</div><div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;logarithms of probabilities, which is equivalent to maximising the joint</div><div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;overall probability:</div><div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;\f{align}{</div><div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;\cal P &amp;=&amp; -2\sum\limits_{events} \log(P_i)</div><div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;\f}</div><div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;where \f$P_i\f$</div><div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;is the PDF value for event \f$i\f$.</div><div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;</div><div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;To get a binned fit, you should create a `BinnedDataSet` instead of the</div><div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;`UnbinnedDataSet`; the procedure is otherwise the same. Notice that the</div><div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;`BinnedDataSet` will use the number of bins that its constituent</div><div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;`Variable`s have at the moment of its creation. Supplying a</div><div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;`BinnedDataSet` to a `GooPdf` (which is the base class of all the</div><div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;`FooPdf` classes such as `GaussianPdf`) will, by default, make it do a</div><div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;binned negative-log-likelihood fit, in which the goodness-of-fit</div><div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;criterion is the sum of the logarithms of the Poisson probability of</div><div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;each bin:</div><div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;\f{align}{</div><div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;{\cal P} &amp;=&amp; -2*\sum\limits_{bins}(N * \log(E) - E)</div><div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;\f}</div><div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;where</div><div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;\f$E\f$ is the expected number of events in a bin and \f$N\f$ is the observed</div><div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;number.</div><div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;</div><div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;There are two non-default variants of binned fits: A chisquare fit where</div><div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;the error on a bin entry is taken as the square root of the number of</div><div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;observed entries in it (or 1 if the bin is empty), and a “bin error” fit</div><div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;where the error on each bin is supplied by the `BinnedDataSet`. To do</div><div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;such a fit, in addition to supplying the `BinnedDataSet` (and providing</div><div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;the errors through the `setBinError` method in the case of the bin error</div><div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;fit), you should create a suitable `FitControl` object and send it to</div><div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;the top-level `GooPdf`:</div><div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;</div><div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;```{.cpp}</div><div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;Variable decayTime {&quot;decayTime&quot;, 100, 0, 10}; </div><div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;BinnedDataSet* ratioData {&amp;decayTime}; </div><div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;for (int i = 0; i &lt; 100; ++i) {</div><div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;  ratioData.SetBinContent(getRatio(i));</div><div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;  ratioData.SetBinError(getError(i));</div><div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;}</div><div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;</div><div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;vector&lt;Variable*&gt; weights;</div><div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;weights.push_back(new Variable(&quot;constaCoef&quot;, 0.03, 0.01, -1, 1));</div><div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;weights.push_back(new Variable(&quot;linearCoef&quot;, 0, 0.01, -1, 1));</div><div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;weights.push_back(new Variable(&quot;secondCoef&quot;, 0, 0.01, -1, 1));</div><div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;</div><div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;PolynomialPdf poly {&quot;poly&quot;, decayTime, weights}; </div><div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;poly.setFitControl(new BinnedErrorFit()); </div><div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;poly.setData(&amp;ratioData); </div><div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;```</div><div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;</div><div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;The `FitControl` classes are `UnbinnedNLLFit` (the default),</div><div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;`BinnedNLLFit` (the default for binned fits), `BinnedErrorFit` and</div><div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;`BinnedChisqFit`.</div><div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;</div><div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;Creating new PDF classes {#newpdfs}</div><div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;========================</div><div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;</div><div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;The simplest way to create a new PDF is to take the existing</div><div class="line"><a name="l00278"></a><span class="lineno">  278</span>&#160;`GaussianPdf` class as a template. The existence of a `FooPdf.cu` file</div><div class="line"><a name="l00279"></a><span class="lineno">  279</span>&#160;in the `FPOINTER` directory is, because of Makefile magic, sufficient to</div><div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160;get the `Foo` PDF included in the GooFit library. However, a certain</div><div class="line"><a name="l00281"></a><span class="lineno">  281</span>&#160;amount of boilerplate is necessary to make the PDF actually work. First</div><div class="line"><a name="l00282"></a><span class="lineno">  282</span>&#160;of all, it needs a device-side function with a particular signature:</div><div class="line"><a name="l00283"></a><span class="lineno">  283</span>&#160;</div><div class="line"><a name="l00284"></a><span class="lineno">  284</span>&#160;</div><div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;Signature of evaluation functions. {#listingfsign}</div><div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160;-------------------------------------------</div><div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160;</div><div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160;```{.cpp}</div><div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;__device__ fptype device_Gaussian (fptype* evt, </div><div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;                                   fptype* p, </div><div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;                                   unsigned int* indices); </div><div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160;```</div><div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;</div><div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;Notice that this is a standalone function, not part of any class; `nvcc`</div><div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160;does not play entirely nicely with device-side polymorphism, which is</div><div class="line"><a name="l00296"></a><span class="lineno">  296</span>&#160;why we organise the code using a table of function pointers - a poor</div><div class="line"><a name="l00297"></a><span class="lineno">  297</span>&#160;man’s implementation of the virtual-function lookups built into C++.</div><div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;Second, we need a pointer to the evaluation function:</div><div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;</div><div class="line"><a name="l00300"></a><span class="lineno">  300</span>&#160;```{.cpp}</div><div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160;__device__ device_function_ptr ptr_to_Gaussian = device_Gaussian; </div><div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160;```</div><div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160;</div><div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160;where `device_function_ptr` is defined (using `typedef`) as a pointer to</div><div class="line"><a name="l00305"></a><span class="lineno">  305</span>&#160;a function with the signature shown in the listing [here](@ref listingfsign):</div><div class="line"><a name="l00306"></a><span class="lineno">  306</span>&#160;</div><div class="line"><a name="l00307"></a><span class="lineno">  307</span>&#160;```{.cpp}</div><div class="line"><a name="l00308"></a><span class="lineno">  308</span>&#160;typedef fptype (*device_function_ptr) (fptype*, </div><div class="line"><a name="l00309"></a><span class="lineno">  309</span>&#160;                                       fptype*, </div><div class="line"><a name="l00310"></a><span class="lineno">  310</span>&#160;                                       unsigned int*);</div><div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160;```</div><div class="line"><a name="l00312"></a><span class="lineno">  312</span>&#160;</div><div class="line"><a name="l00313"></a><span class="lineno">  313</span>&#160;This pointer (\ref footnote4 &quot;4&quot;) will be copied into the `device_function_table` array,</div><div class="line"><a name="l00314"></a><span class="lineno">  314</span>&#160;and its index in that array is the PDF’s internal representation of “my</div><div class="line"><a name="l00315"></a><span class="lineno">  315</span>&#160;evaluation function”.</div><div class="line"><a name="l00316"></a><span class="lineno">  316</span>&#160;</div><div class="line"><a name="l00317"></a><span class="lineno">  317</span>&#160;Finally, the new PDF needs a bog-standard C++ class definition,</div><div class="line"><a name="l00318"></a><span class="lineno">  318</span>&#160;extending the `GooPdf` superclass, which will allow it to be</div><div class="line"><a name="l00319"></a><span class="lineno">  319</span>&#160;instantiated and passed around in user-level code. [The indeces section](@ref subindexarray)</div><div class="line"><a name="l00320"></a><span class="lineno">  320</span>&#160;discusses what should happen in the constructor;</div><div class="line"><a name="l00321"></a><span class="lineno">  321</span>&#160;otherwise the class may have any supporting paraphernalia that are</div><div class="line"><a name="l00322"></a><span class="lineno">  322</span>&#160;necessary or useful to its evaluation - caches, lists of components,</div><div class="line"><a name="l00323"></a><span class="lineno">  323</span>&#160;pointers to device-side constants, whatever.</div><div class="line"><a name="l00324"></a><span class="lineno">  324</span>&#160;</div><div class="line"><a name="l00325"></a><span class="lineno">  325</span>&#160;The indices array {#subindexarray}</div><div class="line"><a name="l00326"></a><span class="lineno">  326</span>&#160;-----------------</div><div class="line"><a name="l00327"></a><span class="lineno">  327</span>&#160;</div><div class="line"><a name="l00328"></a><span class="lineno">  328</span>&#160;The heart of a PDF’s organisation is its index array, which appears in</div><div class="line"><a name="l00329"></a><span class="lineno">  329</span>&#160;the arguments to its device-side evaluation function as</div><div class="line"><a name="l00330"></a><span class="lineno">  330</span>&#160;`unsigned int* indices`. The index array stores the position of the</div><div class="line"><a name="l00331"></a><span class="lineno">  331</span>&#160;parameters of the PDF within the global parameter array; this allows</div><div class="line"><a name="l00332"></a><span class="lineno">  332</span>&#160;different PDFs to share the same parameters, as in two Gaussians with a</div><div class="line"><a name="l00333"></a><span class="lineno">  333</span>&#160;common mean. It also stores the position of the event variables,</div><div class="line"><a name="l00334"></a><span class="lineno">  334</span>&#160;sometimes called observables, within the event array passed to the</div><div class="line"><a name="l00335"></a><span class="lineno">  335</span>&#160;evaluation function; this is the argument `fptype* evt`.</div><div class="line"><a name="l00336"></a><span class="lineno">  336</span>&#160;</div><div class="line"><a name="l00337"></a><span class="lineno">  337</span>&#160;The index array is created by the constructor of a PDF class; in</div><div class="line"><a name="l00338"></a><span class="lineno">  338</span>&#160;particular, the constructor should call `registerParameter` so as to</div><div class="line"><a name="l00339"></a><span class="lineno">  339</span>&#160;obtain the global indices of its parameters, store these numbers in a</div><div class="line"><a name="l00340"></a><span class="lineno">  340</span>&#160;`vector&lt;unsigned int&gt;` (conventionally called `pindices`), and pass this</div><div class="line"><a name="l00341"></a><span class="lineno">  341</span>&#160;`vector` to `initialize`. The PDF constructor should also call</div><div class="line"><a name="l00342"></a><span class="lineno">  342</span>&#160;`registerObservable` on each of the event variables it depends on.</div><div class="line"><a name="l00343"></a><span class="lineno">  343</span>&#160;</div><div class="line"><a name="l00344"></a><span class="lineno">  344</span>&#160;The `initialize` method constructs the array that is used on the GPU</div><div class="line"><a name="l00345"></a><span class="lineno">  345</span>&#160;side, which consists of four parts. First is stored the number of</div><div class="line"><a name="l00346"></a><span class="lineno">  346</span>&#160;parameters, which is equal to the size of the `pindices vector`. Next</div><div class="line"><a name="l00347"></a><span class="lineno">  347</span>&#160;come the indices of the parameters, in the order they were put into</div><div class="line"><a name="l00348"></a><span class="lineno">  348</span>&#160;`pindices`. Then comes the number of observables, and finally the</div><div class="line"><a name="l00349"></a><span class="lineno">  349</span>&#160;indices of the observables, again in the order they were registered.</div><div class="line"><a name="l00350"></a><span class="lineno">  350</span>&#160;</div><div class="line"><a name="l00351"></a><span class="lineno">  351</span>&#160;An example may be useful at this point. Consider the simple Gaussian PDF</div><div class="line"><a name="l00352"></a><span class="lineno">  352</span>&#160;constructor:</div><div class="line"><a name="l00353"></a><span class="lineno">  353</span>&#160;</div><div class="line"><a name="l00354"></a><span class="lineno">  354</span>&#160;```{.cpp}</div><div class="line"><a name="l00355"></a><span class="lineno">  355</span>&#160;GaussianPdf::GaussianPdf (std::string n, </div><div class="line"><a name="l00356"></a><span class="lineno">  356</span>&#160;                          Variable* _x, </div><div class="line"><a name="l00357"></a><span class="lineno">  357</span>&#160;                          Variable* mean, </div><div class="line"><a name="l00358"></a><span class="lineno">  358</span>&#160;                          Variable* sigma) </div><div class="line"><a name="l00359"></a><span class="lineno">  359</span>&#160;  : GooPdf(_x, n) </div><div class="line"><a name="l00360"></a><span class="lineno">  360</span>&#160;{</div><div class="line"><a name="l00361"></a><span class="lineno">  361</span>&#160;  std::vector&lt;unsigned int&gt; pindices;</div><div class="line"><a name="l00362"></a><span class="lineno">  362</span>&#160;  pindices.push_back(registerParameter(mean));</div><div class="line"><a name="l00363"></a><span class="lineno">  363</span>&#160;  pindices.push_back(registerParameter(sigma));</div><div class="line"><a name="l00364"></a><span class="lineno">  364</span>&#160;  MEMCPY_FROM_SYMBOL((void**) &amp;host_fcn_ptr, </div><div class="line"><a name="l00365"></a><span class="lineno">  365</span>&#160;                       ptr_to_Gaussian, </div><div class="line"><a name="l00366"></a><span class="lineno">  366</span>&#160;                       sizeof(void*));</div><div class="line"><a name="l00367"></a><span class="lineno">  367</span>&#160;  initialize(pindices); </div><div class="line"><a name="l00368"></a><span class="lineno">  368</span>&#160;}</div><div class="line"><a name="l00369"></a><span class="lineno">  369</span>&#160;```</div><div class="line"><a name="l00370"></a><span class="lineno">  370</span>&#160;</div><div class="line"><a name="l00371"></a><span class="lineno">  371</span>&#160;This is almost the simplest possible PDF: Two parameters, one</div><div class="line"><a name="l00372"></a><span class="lineno">  372</span>&#160;observable, no messing about! Notice that the call to</div><div class="line"><a name="l00373"></a><span class="lineno">  373</span>&#160;`registerObservable` is done in the parent `GooPdf` constructor - this</div><div class="line"><a name="l00374"></a><span class="lineno">  374</span>&#160;saves some boilerplate in the constructors of one-observable PDFs. For</div><div class="line"><a name="l00375"></a><span class="lineno">  375</span>&#160;the second and subsequent observables the calls should be done manually.</div><div class="line"><a name="l00376"></a><span class="lineno">  376</span>&#160;The device-side index array for the Gaussian, assuming it is the only</div><div class="line"><a name="l00377"></a><span class="lineno">  377</span>&#160;PDF in the system, looks like this:</div><div class="line"><a name="l00378"></a><span class="lineno">  378</span>&#160;</div><div class="line"><a name="l00379"></a><span class="lineno">  379</span>&#160;    index  0 1 2 3 4</div><div class="line"><a name="l00380"></a><span class="lineno">  380</span>&#160;    value  2 0 1 1 0</div><div class="line"><a name="l00381"></a><span class="lineno">  381</span>&#160;</div><div class="line"><a name="l00382"></a><span class="lineno">  382</span>&#160;Here the initial 2 is the number of parameters - mean and sigma. Then</div><div class="line"><a name="l00383"></a><span class="lineno">  383</span>&#160;come their respective indices; since by assumption the Gaussian is the</div><div class="line"><a name="l00384"></a><span class="lineno">  384</span>&#160;only PDF we’re constructing, these will simply be 0 and 1. Then comes</div><div class="line"><a name="l00385"></a><span class="lineno">  385</span>&#160;the number of observables, which is 1, and finally the index of the</div><div class="line"><a name="l00386"></a><span class="lineno">  386</span>&#160;observable - which, as it is the only observable registered, must be 0.</div><div class="line"><a name="l00387"></a><span class="lineno">  387</span>&#160;Now we can consider how the device-side code makes use of this:</div><div class="line"><a name="l00388"></a><span class="lineno">  388</span>&#160;</div><div class="line"><a name="l00389"></a><span class="lineno">  389</span>&#160;```{.cpp}</div><div class="line"><a name="l00390"></a><span class="lineno">  390</span>&#160;__device__ fptype device_Gaussian (fptype* evt, </div><div class="line"><a name="l00391"></a><span class="lineno">  391</span>&#160;                                   fptype* p, </div><div class="line"><a name="l00392"></a><span class="lineno">  392</span>&#160;                                   unsigned int* indices) {</div><div class="line"><a name="l00393"></a><span class="lineno">  393</span>&#160;  fptype x = evt[indices[2 + indices[0]]]; </div><div class="line"><a name="l00394"></a><span class="lineno">  394</span>&#160;  fptype mean = p[indices[1]];</div><div class="line"><a name="l00395"></a><span class="lineno">  395</span>&#160;  fptype sigma = p[indices[2]];</div><div class="line"><a name="l00396"></a><span class="lineno">  396</span>&#160;</div><div class="line"><a name="l00397"></a><span class="lineno">  397</span>&#160;  fptype ret = exp(-0.5*(x-mean)*(x-mean)/(sigma*sigma));</div><div class="line"><a name="l00398"></a><span class="lineno">  398</span>&#160;  return ret; </div><div class="line"><a name="l00399"></a><span class="lineno">  399</span>&#160;}</div><div class="line"><a name="l00400"></a><span class="lineno">  400</span>&#160;```</div><div class="line"><a name="l00401"></a><span class="lineno">  401</span>&#160;</div><div class="line"><a name="l00402"></a><span class="lineno">  402</span>&#160;The calculation of the Gaussian is straightforward enough, but let’s</div><div class="line"><a name="l00403"></a><span class="lineno">  403</span>&#160;look at where the numbers `mean, sigma` and especially `x` come from.</div><div class="line"><a name="l00404"></a><span class="lineno">  404</span>&#160;The function is passed a pointer to the particular event it is to</div><div class="line"><a name="l00405"></a><span class="lineno">  405</span>&#160;calculate the value for, a global parameter array, and the index array.</div><div class="line"><a name="l00406"></a><span class="lineno">  406</span>&#160;The parameter array, in the case of a single Gaussian, consists simply</div><div class="line"><a name="l00407"></a><span class="lineno">  407</span>&#160;of the values for the mean and sigma in the current MINUIT iteration.</div><div class="line"><a name="l00408"></a><span class="lineno">  408</span>&#160;Let us replace the index lookups in those lines with their values from</div><div class="line"><a name="l00409"></a><span class="lineno">  409</span>&#160;above:</div><div class="line"><a name="l00410"></a><span class="lineno">  410</span>&#160;</div><div class="line"><a name="l00411"></a><span class="lineno">  411</span>&#160;```{.cpp}</div><div class="line"><a name="l00412"></a><span class="lineno">  412</span>&#160;fptype mean = p[0];</div><div class="line"><a name="l00413"></a><span class="lineno">  413</span>&#160;fptype sigma = p[1]; </div><div class="line"><a name="l00414"></a><span class="lineno">  414</span>&#160;```</div><div class="line"><a name="l00415"></a><span class="lineno">  415</span>&#160;</div><div class="line"><a name="l00416"></a><span class="lineno">  416</span>&#160;which is exactly what we want. The fetching of `x` appears a little more</div><div class="line"><a name="l00417"></a><span class="lineno">  417</span>&#160;formidable, with its double `indices` lookup; it calls for some</div><div class="line"><a name="l00418"></a><span class="lineno">  418</span>&#160;explanation. First, `indices[0]` is the number of parameters of the</div><div class="line"><a name="l00419"></a><span class="lineno">  419</span>&#160;function; we want to skip ahead by this number to get to the ‘event’</div><div class="line"><a name="l00420"></a><span class="lineno">  420</span>&#160;part of the array. In the Gaussian, this is known at compile-time to be</div><div class="line"><a name="l00421"></a><span class="lineno">  421</span>&#160;2, but not every PDF writer is so fortunate; a polynomial PDF, for</div><div class="line"><a name="l00422"></a><span class="lineno">  422</span>&#160;example, could have an arbitrary number of parameters. (Or it might</div><div class="line"><a name="l00423"></a><span class="lineno">  423</span>&#160;specify a maximum number, say 10, and in most cases leave seven or eight</div><div class="line"><a name="l00424"></a><span class="lineno">  424</span>&#160;of them fixed at zero - but then there would be a lot of wasted</div><div class="line"><a name="l00425"></a><span class="lineno">  425</span>&#160;multiplications-by-zero and additions-of-zero.) Thus, as a convention,</div><div class="line"><a name="l00426"></a><span class="lineno">  426</span>&#160;lookups of event variables should always use `indices[0]` even if the</div><div class="line"><a name="l00427"></a><span class="lineno">  427</span>&#160;coder knows what that number is going to be. Then, 2 must be added to</div><div class="line"><a name="l00428"></a><span class="lineno">  428</span>&#160;this number to account for the space taken by the number-of-parameters</div><div class="line"><a name="l00429"></a><span class="lineno">  429</span>&#160;and number-of-observables entries in the array. So, replacing the first</div><div class="line"><a name="l00430"></a><span class="lineno">  430</span>&#160;level of lookup by the values, we have:</div><div class="line"><a name="l00431"></a><span class="lineno">  431</span>&#160;</div><div class="line"><a name="l00432"></a><span class="lineno">  432</span>&#160;```{.cpp}</div><div class="line"><a name="l00433"></a><span class="lineno">  433</span>&#160;fptype x = evt[indices[4]]; </div><div class="line"><a name="l00434"></a><span class="lineno">  434</span>&#160;```</div><div class="line"><a name="l00435"></a><span class="lineno">  435</span>&#160;</div><div class="line"><a name="l00436"></a><span class="lineno">  436</span>&#160;and `indices[4]` is just 0; so in other words, `x` is the first</div><div class="line"><a name="l00437"></a><span class="lineno">  437</span>&#160;observable in the event. In the case of the single Gaussian, it is also</div><div class="line"><a name="l00438"></a><span class="lineno">  438</span>&#160;the *only* observable, so we’ve done quite a bit of work to arrive at a</div><div class="line"><a name="l00439"></a><span class="lineno">  439</span>&#160;zero that we knew from the start; but in more complex fits this would</div><div class="line"><a name="l00440"></a><span class="lineno">  440</span>&#160;not be true. The `x` variable could be observable number 5, for all we</div><div class="line"><a name="l00441"></a><span class="lineno">  441</span>&#160;know to the contrary in the general case. Likewise the mean and sigma</div><div class="line"><a name="l00442"></a><span class="lineno">  442</span>&#160;could be stored at positions 80 and 101 of the global parameter array.</div><div class="line"><a name="l00443"></a><span class="lineno">  443</span>&#160;</div><div class="line"><a name="l00444"></a><span class="lineno">  444</span>&#160;Constants</div><div class="line"><a name="l00445"></a><span class="lineno">  445</span>&#160;---------</div><div class="line"><a name="l00446"></a><span class="lineno">  446</span>&#160;</div><div class="line"><a name="l00447"></a><span class="lineno">  447</span>&#160;There are two ways of storing constants, or three if we count</div><div class="line"><a name="l00448"></a><span class="lineno">  448</span>&#160;registering a `Variable` as a parameter and telling MINUIT to keep it</div><div class="line"><a name="l00449"></a><span class="lineno">  449</span>&#160;fixed. For integer constants, we may simply store them in the index</div><div class="line"><a name="l00450"></a><span class="lineno">  450</span>&#160;array; since it is up to the programmer to interpret the indices, there</div><div class="line"><a name="l00451"></a><span class="lineno">  451</span>&#160;is no rule that says it absolutely must be taken as an offset into the</div><div class="line"><a name="l00452"></a><span class="lineno">  452</span>&#160;global parameter array! An index can also store integers for any other</div><div class="line"><a name="l00453"></a><span class="lineno">  453</span>&#160;purpose - the maximum degree of a polynomial, flagging the use of an</div><div class="line"><a name="l00454"></a><span class="lineno">  454</span>&#160;optional parameter, or anything else you can think of. Indeed, this is</div><div class="line"><a name="l00455"></a><span class="lineno">  455</span>&#160;exactly what the framework does in enforcing the convention that the</div><div class="line"><a name="l00456"></a><span class="lineno">  456</span>&#160;first number in the index array is the number of parameters.</div><div class="line"><a name="l00457"></a><span class="lineno">  457</span>&#160;</div><div class="line"><a name="l00458"></a><span class="lineno">  458</span>&#160;However, this will not serve for non-integer-valued constants. They must</div><div class="line"><a name="l00459"></a><span class="lineno">  459</span>&#160;either go through MINUIT as fixed parameters, or else go into the</div><div class="line"><a name="l00460"></a><span class="lineno">  460</span>&#160;`functorConstants` array. `functorConstants` works just like the global</div><div class="line"><a name="l00461"></a><span class="lineno">  461</span>&#160;parameters array, except that it does not update on every MINUIT</div><div class="line"><a name="l00462"></a><span class="lineno">  462</span>&#160;iteration since it is meant for storing constants. To use it, you should</div><div class="line"><a name="l00463"></a><span class="lineno">  463</span>&#160;first reserve some space in it using the `registerConstants` method,</div><div class="line"><a name="l00464"></a><span class="lineno">  464</span>&#160;which takes the number of constants you want as an argument and returns</div><div class="line"><a name="l00465"></a><span class="lineno">  465</span>&#160;the index of the first one. Usually you will want to put that index in</div><div class="line"><a name="l00466"></a><span class="lineno">  466</span>&#160;the `pindices` array. For example, suppose I want to store \f$\sqrt{2\pi}\f$</div><div class="line"><a name="l00467"></a><span class="lineno">  467</span>&#160;as a constant for use in the Gaussian. Then I would modify the</div><div class="line"><a name="l00468"></a><span class="lineno">  468</span>&#160;constructor thus:</div><div class="line"><a name="l00469"></a><span class="lineno">  469</span>&#160;</div><div class="line"><a name="l00470"></a><span class="lineno">  470</span>&#160;```{.cpp}</div><div class="line"><a name="l00471"></a><span class="lineno">  471</span>&#160;__host__ GaussianPdf::GaussianPdf (std::string n, </div><div class="line"><a name="l00472"></a><span class="lineno">  472</span>&#160;                                   Variable* _x, </div><div class="line"><a name="l00473"></a><span class="lineno">  473</span>&#160;                                   Variable* mean, </div><div class="line"><a name="l00474"></a><span class="lineno">  474</span>&#160;                                   Variable* sigma) </div><div class="line"><a name="l00475"></a><span class="lineno">  475</span>&#160;  : GooPdf(_x, n) </div><div class="line"><a name="l00476"></a><span class="lineno">  476</span>&#160;{</div><div class="line"><a name="l00477"></a><span class="lineno">  477</span>&#160;  std::vector&lt;unsigned int&gt; pindices;</div><div class="line"><a name="l00478"></a><span class="lineno">  478</span>&#160;  pindices.push_back(registerParameter(mean));</div><div class="line"><a name="l00479"></a><span class="lineno">  479</span>&#160;  pindices.push_back(registerParameter(sigma));</div><div class="line"><a name="l00480"></a><span class="lineno">  480</span>&#160;</div><div class="line"><a name="l00481"></a><span class="lineno">  481</span>&#160;  pindices.push_back(registerConstants(1)); </div><div class="line"><a name="l00482"></a><span class="lineno">  482</span>&#160;  fptype sqrt2pi = sqrt(2*M_PI);</div><div class="line"><a name="l00483"></a><span class="lineno">  483</span>&#160;  MEMCPY_TO_SYMBOL(functorConstants, &amp;sqrt2pi, sizeof(fptype), </div><div class="line"><a name="l00484"></a><span class="lineno">  484</span>&#160;                     cIndex*sizeof(fptype), cudaMemcpyHostToDevice); </div><div class="line"><a name="l00485"></a><span class="lineno">  485</span>&#160;</div><div class="line"><a name="l00486"></a><span class="lineno">  486</span>&#160;  MEMCPY_FROM_SYMBOL((void**) &amp;host_fcn_ptr, ptr_to_Gaussian, sizeof(void*));</div><div class="line"><a name="l00487"></a><span class="lineno">  487</span>&#160;  initialize(pindices); </div><div class="line"><a name="l00488"></a><span class="lineno">  488</span>&#160;}</div><div class="line"><a name="l00489"></a><span class="lineno">  489</span>&#160;```</div><div class="line"><a name="l00490"></a><span class="lineno">  490</span>&#160;</div><div class="line"><a name="l00491"></a><span class="lineno">  491</span>&#160;Notice the member variable `cIndex`, which is set (and returned) by</div><div class="line"><a name="l00492"></a><span class="lineno">  492</span>&#160;`registerConstants`; it is the index of the first constant belonging to</div><div class="line"><a name="l00493"></a><span class="lineno">  493</span>&#160;this object. To extract my constant for use in the device function, I</div><div class="line"><a name="l00494"></a><span class="lineno">  494</span>&#160;look it up as though it were a parameter, but the target array is</div><div class="line"><a name="l00495"></a><span class="lineno">  495</span>&#160;`functorConstants` instead of the passed-in `p`:</div><div class="line"><a name="l00496"></a><span class="lineno">  496</span>&#160;</div><div class="line"><a name="l00497"></a><span class="lineno">  497</span>&#160;```{.cpp}</div><div class="line"><a name="l00498"></a><span class="lineno">  498</span>&#160;__device__ fptype device_Gaussian (fptype* evt, </div><div class="line"><a name="l00499"></a><span class="lineno">  499</span>&#160;                                   fptype* p, </div><div class="line"><a name="l00500"></a><span class="lineno">  500</span>&#160;                                   unsigned int* indices) {</div><div class="line"><a name="l00501"></a><span class="lineno">  501</span>&#160;  fptype x = evt[indices[2 + indices[0]]]; </div><div class="line"><a name="l00502"></a><span class="lineno">  502</span>&#160;  fptype mean = p[indices[1]];</div><div class="line"><a name="l00503"></a><span class="lineno">  503</span>&#160;  fptype sigma = p[indices[2]];</div><div class="line"><a name="l00504"></a><span class="lineno">  504</span>&#160;  fptype sqrt2pi = functorConstants[indices[3]];</div><div class="line"><a name="l00505"></a><span class="lineno">  505</span>&#160;</div><div class="line"><a name="l00506"></a><span class="lineno">  506</span>&#160;  fptype ret = exp(-0.5*(x-mean)*(x-mean)/(sigma*sigma));</div><div class="line"><a name="l00507"></a><span class="lineno">  507</span>&#160;  ret /= sqrt2pi; </div><div class="line"><a name="l00508"></a><span class="lineno">  508</span>&#160;  return ret; </div><div class="line"><a name="l00509"></a><span class="lineno">  509</span>&#160;}</div><div class="line"><a name="l00510"></a><span class="lineno">  510</span>&#160;```</div><div class="line"><a name="l00511"></a><span class="lineno">  511</span>&#160;</div><div class="line"><a name="l00512"></a><span class="lineno">  512</span>&#160;If I had registered two constants instead of one, the second one would</div><div class="line"><a name="l00513"></a><span class="lineno">  513</span>&#160;be looked up by `functorConstants[indices[3] + 1]`, not the</div><div class="line"><a name="l00514"></a><span class="lineno">  514</span>&#160;`functorConstants[indices[4]]` one might naively expect. This is because</div><div class="line"><a name="l00515"></a><span class="lineno">  515</span>&#160;the constant is stored next to the first one registered, but its *index*</div><div class="line"><a name="l00516"></a><span class="lineno">  516</span>&#160;is not stored at all; it has to be calculated from the index of the</div><div class="line"><a name="l00517"></a><span class="lineno">  517</span>&#160;first constant. Thus the `+1` must go outside the indices lookup, not</div><div class="line"><a name="l00518"></a><span class="lineno">  518</span>&#160;inside it! Keeping the levels of indirection straight when constructing</div><div class="line"><a name="l00519"></a><span class="lineno">  519</span>&#160;this sort of code calls for some care and attention.</div><div class="line"><a name="l00520"></a><span class="lineno">  520</span>&#160;</div><div class="line"><a name="l00521"></a><span class="lineno">  521</span>&#160;Note that `functorConstants[0]` is reserved for the number of events in</div><div class="line"><a name="l00522"></a><span class="lineno">  522</span>&#160;the fit.</div><div class="line"><a name="l00523"></a><span class="lineno">  523</span>&#160;</div><div class="line"><a name="l00524"></a><span class="lineno">  524</span>&#160;Program flow {#engine}</div><div class="line"><a name="l00525"></a><span class="lineno">  525</span>&#160;============</div><div class="line"><a name="l00526"></a><span class="lineno">  526</span>&#160;</div><div class="line"><a name="l00527"></a><span class="lineno">  527</span>&#160;This section narrates the course of a fit after it is created, passing</div><div class="line"><a name="l00528"></a><span class="lineno">  528</span>&#160;through MINUIT and the core GooFit engine. In particular, we will</div><div class="line"><a name="l00529"></a><span class="lineno">  529</span>&#160;consider the example Gaussian fit shown in listing [Gauss fit](@ref listinggaussfit)</div><div class="line"><a name="l00530"></a><span class="lineno">  530</span>&#160;and look at what happens in these innocent-looking lines:</div><div class="line"><a name="l00531"></a><span class="lineno">  531</span>&#160;</div><div class="line"><a name="l00532"></a><span class="lineno">  532</span>&#160;## Data transfer and fit invocation {#listingactualfit}</div><div class="line"><a name="l00533"></a><span class="lineno">  533</span>&#160;</div><div class="line"><a name="l00534"></a><span class="lineno">  534</span>&#160;```{.cpp}</div><div class="line"><a name="l00535"></a><span class="lineno">  535</span>&#160;gauss.setData(&amp;data);</div><div class="line"><a name="l00536"></a><span class="lineno">  536</span>&#160;FitManager fitter(&amp;gauss); </div><div class="line"><a name="l00537"></a><span class="lineno">  537</span>&#160;fitter.fit(); </div><div class="line"><a name="l00538"></a><span class="lineno">  538</span>&#160;```</div><div class="line"><a name="l00539"></a><span class="lineno">  539</span>&#160;</div><div class="line"><a name="l00540"></a><span class="lineno">  540</span>&#160;Copying data</div><div class="line"><a name="l00541"></a><span class="lineno">  541</span>&#160;------------</div><div class="line"><a name="l00542"></a><span class="lineno">  542</span>&#160;</div><div class="line"><a name="l00543"></a><span class="lineno">  543</span>&#160;The `setData` method copies the contents of the supplied `DataSet` to</div><div class="line"><a name="l00544"></a><span class="lineno">  544</span>&#160;the GPU:</div><div class="line"><a name="l00545"></a><span class="lineno">  545</span>&#160;</div><div class="line"><a name="l00546"></a><span class="lineno">  546</span>&#160;Internals of the setData method {#listingsetData}</div><div class="line"><a name="l00547"></a><span class="lineno">  547</span>&#160;--------------------------------------------------</div><div class="line"><a name="l00548"></a><span class="lineno">  548</span>&#160;</div><div class="line"><a name="l00549"></a><span class="lineno">  549</span>&#160;```{.cpp}</div><div class="line"><a name="l00550"></a><span class="lineno">  550</span>&#160;setIndices();</div><div class="line"><a name="l00551"></a><span class="lineno">  551</span>&#160;int dimensions = observables.size();</div><div class="line"><a name="l00552"></a><span class="lineno">  552</span>&#160;numEntries = data-&gt;getNumEvents(); </div><div class="line"><a name="l00553"></a><span class="lineno">  553</span>&#160;numEvents = numEntries; </div><div class="line"><a name="l00554"></a><span class="lineno">  554</span>&#160;</div><div class="line"><a name="l00555"></a><span class="lineno">  555</span>&#160;fptype* host_array = new fptype[numEntries*dimensions];</div><div class="line"><a name="l00556"></a><span class="lineno">  556</span>&#160;for (int i = 0; i &lt; numEntries; ++i) {</div><div class="line"><a name="l00557"></a><span class="lineno">  557</span>&#160;  for (obsIter v = obsBegin(); v != obsEnd(); ++v) {</div><div class="line"><a name="l00558"></a><span class="lineno">  558</span>&#160;    fptype currVal = data-&gt;getValue((*v), i);</div><div class="line"><a name="l00559"></a><span class="lineno">  559</span>&#160;    host_array[i*dimensions + (*v)-&gt;index] = currVal; </div><div class="line"><a name="l00560"></a><span class="lineno">  560</span>&#160;  }</div><div class="line"><a name="l00561"></a><span class="lineno">  561</span>&#160;}</div><div class="line"><a name="l00562"></a><span class="lineno">  562</span>&#160;</div><div class="line"><a name="l00563"></a><span class="lineno">  563</span>&#160;gooMalloc((void**) &amp;dev_event_array, dimensions*numEntries*sizeof(fptype)); </div><div class="line"><a name="l00564"></a><span class="lineno">  564</span>&#160;cudaMemcpy(dev_event_array, host_array, dimensions*numEntries*sizeof(fptype), cudaMemcpyHostToDevice);</div><div class="line"><a name="l00565"></a><span class="lineno">  565</span>&#160;MEMCPY_TO_SYMBOL(functorConstants, &amp;numEvents, sizeof(fptype), 0, cudaMemcpyHostToDevice); </div><div class="line"><a name="l00566"></a><span class="lineno">  566</span>&#160;delete[] host_array; </div><div class="line"><a name="l00567"></a><span class="lineno">  567</span>&#160;```</div><div class="line"><a name="l00568"></a><span class="lineno">  568</span>&#160;</div><div class="line"><a name="l00569"></a><span class="lineno">  569</span>&#160;Notice the call to `setIndices`; this is where the indices of</div><div class="line"><a name="l00570"></a><span class="lineno">  570</span>&#160;observables passed to the PDF are decided and copied into the indices</div><div class="line"><a name="l00571"></a><span class="lineno">  571</span>&#160;array. This step cannot be done before all the subcomponents of the PDF</div><div class="line"><a name="l00572"></a><span class="lineno">  572</span>&#160;have had a chance to register their observables. Hence `setData` should</div><div class="line"><a name="l00573"></a><span class="lineno">  573</span>&#160;be called only after the creation of all PDF components, and only on the</div><div class="line"><a name="l00574"></a><span class="lineno">  574</span>&#160;top-level PDF.</div><div class="line"><a name="l00575"></a><span class="lineno">  575</span>&#160;</div><div class="line"><a name="l00576"></a><span class="lineno">  576</span>&#160;The array thus created has the simple structure</div><div class="line"><a name="l00577"></a><span class="lineno">  577</span>&#160;`x1 y1 z1 x2 y2 z2 ... xN yN zN`, that is, the events are laid out</div><div class="line"><a name="l00578"></a><span class="lineno">  578</span>&#160;contiguously in memory, each event consisting simply of the observables,</div><div class="line"><a name="l00579"></a><span class="lineno">  579</span>&#160;in the same order every time. Notice that if the `DataSet` contains</div><div class="line"><a name="l00580"></a><span class="lineno">  580</span>&#160;`Variable`s that have not been registered as observables, they are</div><div class="line"><a name="l00581"></a><span class="lineno">  581</span>&#160;ignored. If `setData` is called with an `BinnedDataSet` object, the</div><div class="line"><a name="l00582"></a><span class="lineno">  582</span>&#160;procedure is similar except that each ‘event’ consists of the</div><div class="line"><a name="l00583"></a><span class="lineno">  583</span>&#160;coordinates of the bin center, the number of events in the bin, and</div><div class="line"><a name="l00584"></a><span class="lineno">  584</span>&#160;either the bin error or the bin size. We will see later how the engine</div><div class="line"><a name="l00585"></a><span class="lineno">  585</span>&#160;uses the `dev_event_array` either as a list of events or a list of bins.</div><div class="line"><a name="l00586"></a><span class="lineno">  586</span>&#160;</div><div class="line"><a name="l00587"></a><span class="lineno">  587</span>&#160;MINUIT setup</div><div class="line"><a name="l00588"></a><span class="lineno">  588</span>&#160;------------</div><div class="line"><a name="l00589"></a><span class="lineno">  589</span>&#160;</div><div class="line"><a name="l00590"></a><span class="lineno">  590</span>&#160;Having copied the data to the GPU, the next task is to create the MINUIT</div><div class="line"><a name="l00591"></a><span class="lineno">  591</span>&#160;object that will do the actual fit; this is done by creating a</div><div class="line"><a name="l00592"></a><span class="lineno">  592</span>&#160;`FitManager` object, with the top-level PDF as its argument, and calling</div><div class="line"><a name="l00593"></a><span class="lineno">  593</span>&#160;its `fit` method. The `fit` method does two things: First it calls the</div><div class="line"><a name="l00594"></a><span class="lineno">  594</span>&#160;`getParameters` method of the supplied PDF, which recursively gets the</div><div class="line"><a name="l00595"></a><span class="lineno">  595</span>&#160;registered parameters of all the component PDFs, and from the resulting</div><div class="line"><a name="l00596"></a><span class="lineno">  596</span>&#160;list of `Variable`s it creates MINUIT parameters by calling</div><div class="line"><a name="l00597"></a><span class="lineno">  597</span>&#160;`DefineParameter`. Second, it sets the method `FitFun` to be MINUIT’s</div><div class="line"><a name="l00598"></a><span class="lineno">  598</span>&#160;function-to-minimise, and calls MINUIT’s `mnmigr` method.</div><div class="line"><a name="l00599"></a><span class="lineno">  599</span>&#160;</div><div class="line"><a name="l00600"></a><span class="lineno">  600</span>&#160;A few variants on the above procedure exist. Most obviously, ROOT</div><div class="line"><a name="l00601"></a><span class="lineno">  601</span>&#160;contains three implementations of the MINUIT algorithm, named `TMinuit`,</div><div class="line"><a name="l00602"></a><span class="lineno">  602</span>&#160;`TMinuit2`, and `TVirtualFitter` (\ref footnote5 &quot;5&quot;). One can switch between these by</div><div class="line"><a name="l00603"></a><span class="lineno">  603</span>&#160;setting the constant `MINUIT_VERSION` in FitManager.hh to, respectively,</div><div class="line"><a name="l00604"></a><span class="lineno">  604</span>&#160;1, 2, and 3. The interfaces differ, but the essential procedure is the</div><div class="line"><a name="l00605"></a><span class="lineno">  605</span>&#160;one described above: Define parameters, set function-to-minimise, run</div><div class="line"><a name="l00606"></a><span class="lineno">  606</span>&#160;MIGRAD. (NB: As of v0.2, GooFit has not recently been tested with</div><div class="line"><a name="l00607"></a><span class="lineno">  607</span>&#160;`MINUIT_VERSION` set to 2 or 3.) In the case of `TMinuit`, one can call</div><div class="line"><a name="l00608"></a><span class="lineno">  608</span>&#160;`setMaxCalls` to override the usual MINUIT limitation on the number of</div><div class="line"><a name="l00609"></a><span class="lineno">  609</span>&#160;iterations, although my experience is that this is not usually helpful</div><div class="line"><a name="l00610"></a><span class="lineno">  610</span>&#160;because running into the iteration limit tends to indicate a deeper</div><div class="line"><a name="l00611"></a><span class="lineno">  611</span>&#160;problem with the fit. Finally, the underlying `TMinuit` object is</div><div class="line"><a name="l00612"></a><span class="lineno">  612</span>&#160;available through the `getMinuitObject` method, allowing fine-grained</div><div class="line"><a name="l00613"></a><span class="lineno">  613</span>&#160;control of what MINUIT does, for example by calling `mnhess` in place of</div><div class="line"><a name="l00614"></a><span class="lineno">  614</span>&#160;`mnmigr`.</div><div class="line"><a name="l00615"></a><span class="lineno">  615</span>&#160;</div><div class="line"><a name="l00616"></a><span class="lineno">  616</span>&#160;PDF evaluation</div><div class="line"><a name="l00617"></a><span class="lineno">  617</span>&#160;--------------</div><div class="line"><a name="l00618"></a><span class="lineno">  618</span>&#160;</div><div class="line"><a name="l00619"></a><span class="lineno">  619</span>&#160;We have copied the data to the GPU, set up MINUIT, and invoked `mnmigr`.</div><div class="line"><a name="l00620"></a><span class="lineno">  620</span>&#160;Program flow now passes to MINUIT, which for purposes of this</div><div class="line"><a name="l00621"></a><span class="lineno">  621</span>&#160;documentation is a black box, for some time; it returns to GooFit by</div><div class="line"><a name="l00622"></a><span class="lineno">  622</span>&#160;calling the `FitFun` method with a list of parameters for which MINUIT</div><div class="line"><a name="l00623"></a><span class="lineno">  623</span>&#160;would like us to evaluate the NLL. `FitFun` translates MINUIT indices</div><div class="line"><a name="l00624"></a><span class="lineno">  624</span>&#160;into GooFit indices, and calls `copyParams`, which eponymously copies</div><div class="line"><a name="l00625"></a><span class="lineno">  625</span>&#160;the parameter array to `cudaArray` on the GPU. `FitFun` then returns the</div><div class="line"><a name="l00626"></a><span class="lineno">  626</span>&#160;value from `GooPdf::calculateNLL` to MINUIT, which absorbs the number</div><div class="line"><a name="l00627"></a><span class="lineno">  627</span>&#160;into its inner workings and eventually comes back with another set of</div><div class="line"><a name="l00628"></a><span class="lineno">  628</span>&#160;parameters to be evaluated. Control continues to pass back and forth in</div><div class="line"><a name="l00629"></a><span class="lineno">  629</span>&#160;this way until MINUIT converges or gives up, or until GooFit crashes.</div><div class="line"><a name="l00630"></a><span class="lineno">  630</span>&#160;</div><div class="line"><a name="l00631"></a><span class="lineno">  631</span>&#160;The `calculateNLL` method does two things: First it calls the</div><div class="line"><a name="l00632"></a><span class="lineno">  632</span>&#160;`normalize` function of the PDF, which in turn will usually recursively</div><div class="line"><a name="l00633"></a><span class="lineno">  633</span>&#160;normalize the components; the results of the `normalize` call are copied</div><div class="line"><a name="l00634"></a><span class="lineno">  634</span>&#160;into the `normalisationFactors` array on the GPU. Next it calls</div><div class="line"><a name="l00635"></a><span class="lineno">  635</span>&#160;`sumOfNll` and returns the resulting value. Particular PDF</div><div class="line"><a name="l00636"></a><span class="lineno">  636</span>&#160;implementations may override `sumOfNll`; most notably `AddPdf` does so</div><div class="line"><a name="l00637"></a><span class="lineno">  637</span>&#160;in order to have the option of returning an ‘extended’ likelihood, with</div><div class="line"><a name="l00638"></a><span class="lineno">  638</span>&#160;a term for the Poisson probability of the observed number of events in</div><div class="line"><a name="l00639"></a><span class="lineno">  639</span>&#160;addition to the event probabilities.</div><div class="line"><a name="l00640"></a><span class="lineno">  640</span>&#160;</div><div class="line"><a name="l00641"></a><span class="lineno">  641</span>&#160;The `normalize` method, by default, simply evaluates the PDF at a grid</div><div class="line"><a name="l00642"></a><span class="lineno">  642</span>&#160;of points, returning the sum of all the values multiplied by the grid</div><div class="line"><a name="l00643"></a><span class="lineno">  643</span>&#160;fineness - a primitive algorithm for numerical integration, but one</div><div class="line"><a name="l00644"></a><span class="lineno">  644</span>&#160;which takes advantage of the GPU’s massive parallelisation. The fineness</div><div class="line"><a name="l00645"></a><span class="lineno">  645</span>&#160;of the grid usually depends on the getNumBins` member of the observables;</div><div class="line"><a name="l00646"></a><span class="lineno">  646</span>&#160;in the case of the example Gaussian fit in listing [Gauss fit](@ref listinggaussfit),</div><div class="line"><a name="l00647"></a><span class="lineno">  647</span>&#160;the PDF will be evaluated at 1000 points, evenly spaced between -5 and 5.</div><div class="line"><a name="l00648"></a><span class="lineno">  648</span>&#160;However, this behaviour can be overridden by calling the</div><div class="line"><a name="l00649"></a><span class="lineno">  649</span>&#160;`setIntegrationFineness` method of the PDF object, in which case the</div><div class="line"><a name="l00650"></a><span class="lineno">  650</span>&#160;number of bins (in each observable) will be equal to the supplied</div><div class="line"><a name="l00651"></a><span class="lineno">  651</span>&#160;fineness.</div><div class="line"><a name="l00652"></a><span class="lineno">  652</span>&#160;</div><div class="line"><a name="l00653"></a><span class="lineno">  653</span>&#160;Stripped of complications, the essential part of the `normalize`</div><div class="line"><a name="l00654"></a><span class="lineno">  654</span>&#160;function is a call to `transform_reduce`:</div><div class="line"><a name="l00655"></a><span class="lineno">  655</span>&#160;</div><div class="line"><a name="l00656"></a><span class="lineno">  656</span>&#160;Normalisation code. {#listingnormalisation}</div><div class="line"><a name="l00657"></a><span class="lineno">  657</span>&#160;------------------------------------------</div><div class="line"><a name="l00658"></a><span class="lineno">  658</span>&#160;</div><div class="line"><a name="l00659"></a><span class="lineno">  659</span>&#160;```{.cpp}</div><div class="line"><a name="l00660"></a><span class="lineno">  660</span>&#160;fptype dummy = 0; </div><div class="line"><a name="l00661"></a><span class="lineno">  661</span>&#160;static plus&lt;fptype&gt; cudaPlus;</div><div class="line"><a name="l00662"></a><span class="lineno">  662</span>&#160;constant_iterator&lt;fptype*&gt; arrayAddress(normRanges); </div><div class="line"><a name="l00663"></a><span class="lineno">  663</span>&#160;constant_iterator&lt;int&gt; eventSize(observables.size());</div><div class="line"><a name="l00664"></a><span class="lineno">  664</span>&#160;counting_iterator&lt;int&gt; binIndex(0); </div><div class="line"><a name="l00665"></a><span class="lineno">  665</span>&#160;</div><div class="line"><a name="l00666"></a><span class="lineno">  666</span>&#160;fptype sum = transform_reduce(make_zip_iterator(</div><div class="line"><a name="l00667"></a><span class="lineno">  667</span>&#160;                               make_tuple(binIndex, </div><div class="line"><a name="l00668"></a><span class="lineno">  668</span>&#160;                                          eventSize, </div><div class="line"><a name="l00669"></a><span class="lineno">  669</span>&#160;                                          arrayAddress)),</div><div class="line"><a name="l00670"></a><span class="lineno">  670</span>&#160;                              make_zip_iterator(</div><div class="line"><a name="l00671"></a><span class="lineno">  671</span>&#160;                               make_tuple(binIndex + totalBins, </div><div class="line"><a name="l00672"></a><span class="lineno">  672</span>&#160;                                          eventSize, </div><div class="line"><a name="l00673"></a><span class="lineno">  673</span>&#160;                                          arrayAddress)),</div><div class="line"><a name="l00674"></a><span class="lineno">  674</span>&#160;              *logger, dummy, cudaPlus); </div><div class="line"><a name="l00675"></a><span class="lineno">  675</span>&#160;```</div><div class="line"><a name="l00676"></a><span class="lineno">  676</span>&#160;</div><div class="line"><a name="l00677"></a><span class="lineno">  677</span>&#160;Here `normRanges` is an array of triplets `lower, upper, bins` for each</div><div class="line"><a name="l00678"></a><span class="lineno">  678</span>&#160;observable, created by the `generateNormRanges` method. The member</div><div class="line"><a name="l00679"></a><span class="lineno">  679</span>&#160;`logger` points to an instance of the `MetricTaker` class, which has an</div><div class="line"><a name="l00680"></a><span class="lineno">  680</span>&#160;operator method that Thrust will invoke on each bin index between the</div><div class="line"><a name="l00681"></a><span class="lineno">  681</span>&#160;initial value of zero and the final value of `totalBins-1`. This</div><div class="line"><a name="l00682"></a><span class="lineno">  682</span>&#160;operator method, which is invoked once per thread with a separate</div><div class="line"><a name="l00683"></a><span class="lineno">  683</span>&#160;(global) bin number for each invocation, calculates the bin center and</div><div class="line"><a name="l00684"></a><span class="lineno">  684</span>&#160;returns the value of the PDF at that point. The `dummy` and `cudaPlus`</div><div class="line"><a name="l00685"></a><span class="lineno">  685</span>&#160;variables merely indicate that Thrust should add (rather than, say,</div><div class="line"><a name="l00686"></a><span class="lineno">  686</span>&#160;multiply) all the returned values, and that it should start the sum at</div><div class="line"><a name="l00687"></a><span class="lineno">  687</span>&#160;zero. The `normalisation` method returns this sum, but stores its</div><div class="line"><a name="l00688"></a><span class="lineno">  688</span>&#160;inverse in the `host_normalisation` array that will eventually be copied</div><div class="line"><a name="l00689"></a><span class="lineno">  689</span>&#160;to `normalisationFactors` on the GPU; this is to allow the</div><div class="line"><a name="l00690"></a><span class="lineno">  690</span>&#160;micro-optimisation of multiplying by the inverse rather than dividing in</div><div class="line"><a name="l00691"></a><span class="lineno">  691</span>&#160;every thread.</div><div class="line"><a name="l00692"></a><span class="lineno">  692</span>&#160;</div><div class="line"><a name="l00693"></a><span class="lineno">  693</span>&#160;PDF implementations may override the `normalisation` method, and among</div><div class="line"><a name="l00694"></a><span class="lineno">  694</span>&#160;the default PDFs, both `AddPdf` and `ProdPdf` do so to ensure that their</div><div class="line"><a name="l00695"></a><span class="lineno">  695</span>&#160;components are correctly normalized. Among the more specialised</div><div class="line"><a name="l00696"></a><span class="lineno">  696</span>&#160;implementations, `TddpPdf` overrides `normalize` so that it may cache</div><div class="line"><a name="l00697"></a><span class="lineno">  697</span>&#160;the slowly-changing Breit-Wigner calculations, and also because its time</div><div class="line"><a name="l00698"></a><span class="lineno">  698</span>&#160;dependence is analytically integrable and it is a good optimisation to</div><div class="line"><a name="l00699"></a><span class="lineno">  699</span>&#160;do only the Dalitz-plot part numerically. This points to a more general</div><div class="line"><a name="l00700"></a><span class="lineno">  700</span>&#160;rule, that once a PDF depends on three or four observables, the</div><div class="line"><a name="l00701"></a><span class="lineno">  701</span>&#160;relatively primitive numerical integration outlined above may become</div><div class="line"><a name="l00702"></a><span class="lineno">  702</span>&#160;unmanageable because of the number of points it creates. Finally, note</div><div class="line"><a name="l00703"></a><span class="lineno">  703</span>&#160;that PDFs may, without overriding `normalize`, advertise an analytical</div><div class="line"><a name="l00704"></a><span class="lineno">  704</span>&#160;integral by overriding `GooPdf`’s `hasAnalyticIntegral` method to return</div><div class="line"><a name="l00705"></a><span class="lineno">  705</span>&#160;`true`, and then implementing an `integrate` method to be evaluated on</div><div class="line"><a name="l00706"></a><span class="lineno">  706</span>&#160;the CPU.</div><div class="line"><a name="l00707"></a><span class="lineno">  707</span>&#160;</div><div class="line"><a name="l00708"></a><span class="lineno">  708</span>&#160;The `logger` object will appear again in the actual PDF evaluation,</div><div class="line"><a name="l00709"></a><span class="lineno">  709</span>&#160;performing a very similar function, so it is worth taking a moment to</div><div class="line"><a name="l00710"></a><span class="lineno">  710</span>&#160;consider in detail exactly what the `transform_reduce` call does. The</div><div class="line"><a name="l00711"></a><span class="lineno">  711</span>&#160;first two parameters (involving `make_tuple` calls) define the range of</div><div class="line"><a name="l00712"></a><span class="lineno">  712</span>&#160;evaluation: In this case, global bins (\ref footnote6 &quot;6&quot;) 0 through \f$N-1\f$. They also</div><div class="line"><a name="l00713"></a><span class="lineno">  713</span>&#160;specify which `operator` method of `MetricTaker` should be called: It is</div><div class="line"><a name="l00714"></a><span class="lineno">  714</span>&#160;the one which takes as arguments two integers (the bin index and event</div><div class="line"><a name="l00715"></a><span class="lineno">  715</span>&#160;size) and an `fptype` array (holding the `normRanges` values), in that</div><div class="line"><a name="l00716"></a><span class="lineno">  716</span>&#160;order. Conceptually, Thrust will create one thread for each unique value</div><div class="line"><a name="l00717"></a><span class="lineno">  717</span>&#160;of the iterator range thus created - that is, one per global bin - and</div><div class="line"><a name="l00718"></a><span class="lineno">  718</span>&#160;have each thread invoke the indicated `operator` method. As a matter of</div><div class="line"><a name="l00719"></a><span class="lineno">  719</span>&#160;organisation on the physical chip, it is likely that Thrust will</div><div class="line"><a name="l00720"></a><span class="lineno">  720</span>&#160;actually create a thousand or so threads and have each thread evaluate</div><div class="line"><a name="l00721"></a><span class="lineno">  721</span>&#160;as many bins as needed; but at any rate, the</div><div class="line"><a name="l00722"></a><span class="lineno">  722</span>&#160;`operator(int, int, fptype*)` method will be called once per global bin.</div><div class="line"><a name="l00723"></a><span class="lineno">  723</span>&#160;The last two arguments indicate that the return value should be</div><div class="line"><a name="l00724"></a><span class="lineno">  724</span>&#160;calculated as the sum of the return values from each `operator`</div><div class="line"><a name="l00725"></a><span class="lineno">  725</span>&#160;invocation, and that the sum should start at zero. Finally, the</div><div class="line"><a name="l00726"></a><span class="lineno">  726</span>&#160;`*logger` argument indicates the specific `MetricTaker` object to use,</div><div class="line"><a name="l00727"></a><span class="lineno">  727</span>&#160;which is important because this is where the function-pointer and</div><div class="line"><a name="l00728"></a><span class="lineno">  728</span>&#160;parameter indices are stored.</div><div class="line"><a name="l00729"></a><span class="lineno">  729</span>&#160;</div><div class="line"><a name="l00730"></a><span class="lineno">  730</span>&#160;The `operator` does two things: First it calculates the bin centers, in</div><div class="line"><a name="l00731"></a><span class="lineno">  731</span>&#160;each observable, of the global bin:</div><div class="line"><a name="l00732"></a><span class="lineno">  732</span>&#160;</div><div class="line"><a name="l00733"></a><span class="lineno">  733</span>&#160;Bin-center calculation {#listingbincenter}</div><div class="line"><a name="l00734"></a><span class="lineno">  734</span>&#160;----------------------</div><div class="line"><a name="l00735"></a><span class="lineno">  735</span>&#160;</div><div class="line"><a name="l00736"></a><span class="lineno">  736</span>&#160;```{.cpp}</div><div class="line"><a name="l00737"></a><span class="lineno">  737</span>&#160;__shared__ fptype binCenters[1024*MAX_NUM_OBSERVABLES];</div><div class="line"><a name="l00738"></a><span class="lineno">  738</span>&#160;</div><div class="line"><a name="l00739"></a><span class="lineno">  739</span>&#160;// To convert global bin number to (x,y,z...) coordinates: </div><div class="line"><a name="l00740"></a><span class="lineno">  740</span>&#160;// For each dimension, take the mod with the number of bins </div><div class="line"><a name="l00741"></a><span class="lineno">  741</span>&#160;// in that dimension. Then divide by the number of bins, in </div><div class="line"><a name="l00742"></a><span class="lineno">  742</span>&#160;// effect collapsing so the grid has one fewer dimension. </div><div class="line"><a name="l00743"></a><span class="lineno">  743</span>&#160;// Rinse and repeat. </div><div class="line"><a name="l00744"></a><span class="lineno">  744</span>&#160;</div><div class="line"><a name="l00745"></a><span class="lineno">  745</span>&#160;int offset = threadIdx.x*MAX_NUM_OBSERVABLES;</div><div class="line"><a name="l00746"></a><span class="lineno">  746</span>&#160;unsigned int* indices = paramIndices + parameters;</div><div class="line"><a name="l00747"></a><span class="lineno">  747</span>&#160;for (int i = 0; i &lt; evtSize; ++i) {</div><div class="line"><a name="l00748"></a><span class="lineno">  748</span>&#160;  fptype lowerBound = thrust::get&lt;2&gt;(t)[3*i+0];</div><div class="line"><a name="l00749"></a><span class="lineno">  749</span>&#160;  fptype upperBound = thrust::get&lt;2&gt;(t)[3*i+1];</div><div class="line"><a name="l00750"></a><span class="lineno">  750</span>&#160;  int numBins    = (int) floor(thrust::get&lt;2&gt;(t)[3*i+2] + 0.5); </div><div class="line"><a name="l00751"></a><span class="lineno">  751</span>&#160;  int localBin = binNumber % numBins;</div><div class="line"><a name="l00752"></a><span class="lineno">  752</span>&#160;</div><div class="line"><a name="l00753"></a><span class="lineno">  753</span>&#160;  fptype x = upperBound - lowerBound; </div><div class="line"><a name="l00754"></a><span class="lineno">  754</span>&#160;  x /= numBins;</div><div class="line"><a name="l00755"></a><span class="lineno">  755</span>&#160;  x *= (localBin + 0.5); </div><div class="line"><a name="l00756"></a><span class="lineno">  756</span>&#160;  x += lowerBound;</div><div class="line"><a name="l00757"></a><span class="lineno">  757</span>&#160;  binCenters[indices[indices[0] + 2 + i]+offset] = x; </div><div class="line"><a name="l00758"></a><span class="lineno">  758</span>&#160;  binNumber /= numBins;</div><div class="line"><a name="l00759"></a><span class="lineno">  759</span>&#160;}</div><div class="line"><a name="l00760"></a><span class="lineno">  760</span>&#160;```</div><div class="line"><a name="l00761"></a><span class="lineno">  761</span>&#160;</div><div class="line"><a name="l00762"></a><span class="lineno">  762</span>&#160;in the straightforward way, and stores the bin centers in a *fake</div><div class="line"><a name="l00763"></a><span class="lineno">  763</span>&#160;event*. Since events are just lists of observables, all that’s necessary</div><div class="line"><a name="l00764"></a><span class="lineno">  764</span>&#160;is to keep track of which part of the `__shared__` (\ref footnote7 &quot;7&quot;) `binCenters`</div><div class="line"><a name="l00765"></a><span class="lineno">  765</span>&#160;array is owned by this thread, look up the index-within-events of each</div><div class="line"><a name="l00766"></a><span class="lineno">  766</span>&#160;observable, and set the entries of the locally-owned part of</div><div class="line"><a name="l00767"></a><span class="lineno">  767</span>&#160;`binCenters` accordingly. This fake event is then sent to the PDF for</div><div class="line"><a name="l00768"></a><span class="lineno">  768</span>&#160;evaluation:</div><div class="line"><a name="l00769"></a><span class="lineno">  769</span>&#160;</div><div class="line"><a name="l00770"></a><span class="lineno">  770</span>&#160;```{.cpp}</div><div class="line"><a name="l00771"></a><span class="lineno">  771</span>&#160;fptype ret = callFunction(binCenters+offset, </div><div class="line"><a name="l00772"></a><span class="lineno">  772</span>&#160;                          functionIdx, </div><div class="line"><a name="l00773"></a><span class="lineno">  773</span>&#160;                          parameters); </div><div class="line"><a name="l00774"></a><span class="lineno">  774</span>&#160;```</div><div class="line"><a name="l00775"></a><span class="lineno">  775</span>&#160;</div><div class="line"><a name="l00776"></a><span class="lineno">  776</span>&#160;where `callFunction` is just a wrapper for looking up the function</div><div class="line"><a name="l00777"></a><span class="lineno">  777</span>&#160;referred to by `functionIdx` and calling it with the right part of the</div><div class="line"><a name="l00778"></a><span class="lineno">  778</span>&#160;parameter array:</div><div class="line"><a name="l00779"></a><span class="lineno">  779</span>&#160;</div><div class="line"><a name="l00780"></a><span class="lineno">  780</span>&#160;</div><div class="line"><a name="l00781"></a><span class="lineno">  781</span>&#160;Code to call device-side PDF implementations (some lines broken up for clarity) {#listingcallfunction}</div><div class="line"><a name="l00782"></a><span class="lineno">  782</span>&#160;----------------------------------</div><div class="line"><a name="l00783"></a><span class="lineno">  783</span>&#160;</div><div class="line"><a name="l00784"></a><span class="lineno">  784</span>&#160;</div><div class="line"><a name="l00785"></a><span class="lineno">  785</span>&#160;```{.cpp}</div><div class="line"><a name="l00786"></a><span class="lineno">  786</span>&#160;__device__ fptype callFunction (fptype* eventAddress, </div><div class="line"><a name="l00787"></a><span class="lineno">  787</span>&#160;                                unsigned int functionIdx, </div><div class="line"><a name="l00788"></a><span class="lineno">  788</span>&#160;                                unsigned int paramIdx) {</div><div class="line"><a name="l00789"></a><span class="lineno">  789</span>&#160;  void* rawPtr = device_function_table[functionIdx];</div><div class="line"><a name="l00790"></a><span class="lineno">  790</span>&#160;  device_function_ptr fcn;</div><div class="line"><a name="l00791"></a><span class="lineno">  791</span>&#160;  fcn = reinterpret_cast&lt;device_function_ptr&gt;(rawPtr);</div><div class="line"><a name="l00792"></a><span class="lineno">  792</span>&#160;  return (*fcn)(eventAddress, </div><div class="line"><a name="l00793"></a><span class="lineno">  793</span>&#160;                cudaArray, </div><div class="line"><a name="l00794"></a><span class="lineno">  794</span>&#160;                paramIndices + paramIdx);</div><div class="line"><a name="l00795"></a><span class="lineno">  795</span>&#160;}</div><div class="line"><a name="l00796"></a><span class="lineno">  796</span>&#160;```</div><div class="line"><a name="l00797"></a><span class="lineno">  797</span>&#160;</div><div class="line"><a name="l00798"></a><span class="lineno">  798</span>&#160;This, finally, is where the `__device__` function from the PDF</div><div class="line"><a name="l00799"></a><span class="lineno">  799</span>&#160;definitions in section [New PDFs](@ref newpdfs) is called; we have now connected</div><div class="line"><a name="l00800"></a><span class="lineno">  800</span>&#160;all this engine code with the evaluation code for the Gaussian,</div><div class="line"><a name="l00801"></a><span class="lineno">  801</span>&#160;Breit-Wigner, polynomial, sum of functions, or whatever calculation we</div><div class="line"><a name="l00802"></a><span class="lineno">  802</span>&#160;happen to be doing today.</div><div class="line"><a name="l00803"></a><span class="lineno">  803</span>&#160;</div><div class="line"><a name="l00804"></a><span class="lineno">  804</span>&#160;Having found the integral of the PDF, either using fake events as</div><div class="line"><a name="l00805"></a><span class="lineno">  805</span>&#160;outlined above or with an analytic calculation, we are now ready to find</div><div class="line"><a name="l00806"></a><span class="lineno">  806</span>&#160;the actual NLL, or sum of chi-squares, or other goodness-of-fit metric,</div><div class="line"><a name="l00807"></a><span class="lineno">  807</span>&#160;using the actual, observed events that we copied across in `setData`.</div><div class="line"><a name="l00808"></a><span class="lineno">  808</span>&#160;The procedure is similar to that for the normalisation:</div><div class="line"><a name="l00809"></a><span class="lineno">  809</span>&#160;</div><div class="line"><a name="l00810"></a><span class="lineno">  810</span>&#160;Goodness-of-fit evaluation {#listingnlleval}</div><div class="line"><a name="l00811"></a><span class="lineno">  811</span>&#160;-----------------</div><div class="line"><a name="l00812"></a><span class="lineno">  812</span>&#160;</div><div class="line"><a name="l00813"></a><span class="lineno">  813</span>&#160;</div><div class="line"><a name="l00814"></a><span class="lineno">  814</span>&#160;```{.cpp}</div><div class="line"><a name="l00815"></a><span class="lineno">  815</span>&#160;transform_reduce(make_zip_iterator(make_tuple(eventIndex, </div><div class="line"><a name="l00816"></a><span class="lineno">  816</span>&#160;                                              arrayAddress, </div><div class="line"><a name="l00817"></a><span class="lineno">  817</span>&#160;                                              eventSize)),</div><div class="line"><a name="l00818"></a><span class="lineno">  818</span>&#160;                 make_zip_iterator(make_tuple(eventIndex + numEntries, </div><div class="line"><a name="l00819"></a><span class="lineno">  819</span>&#160;                                              arrayAddress, </div><div class="line"><a name="l00820"></a><span class="lineno">  820</span>&#160;                                              eventSize)),</div><div class="line"><a name="l00821"></a><span class="lineno">  821</span>&#160;                 *logger, dummy, cudaPlus);   </div><div class="line"><a name="l00822"></a><span class="lineno">  822</span>&#160;```</div><div class="line"><a name="l00823"></a><span class="lineno">  823</span>&#160;</div><div class="line"><a name="l00824"></a><span class="lineno">  824</span>&#160;Here the `*logger`, `dummy`, and `cudaPlus` arguments are doing the same</div><div class="line"><a name="l00825"></a><span class="lineno">  825</span>&#160;jobs as before. The tuple arguments, however, differ: In particular,</div><div class="line"><a name="l00826"></a><span class="lineno">  826</span>&#160;they are now indicating the range 0 to \f$N-1\f$ in *events*, not bins, and</div><div class="line"><a name="l00827"></a><span class="lineno">  827</span>&#160;`arrayAddress` this time points to the array of events, not to a set of</div><div class="line"><a name="l00828"></a><span class="lineno">  828</span>&#160;normalisation triplets from which bin centers can be calculated. Since</div><div class="line"><a name="l00829"></a><span class="lineno">  829</span>&#160;the order of the arguments differs - it is now `int, fptype*, int` - a</div><div class="line"><a name="l00830"></a><span class="lineno">  830</span>&#160;different `operator` method is called:</div><div class="line"><a name="l00831"></a><span class="lineno">  831</span>&#160;</div><div class="line"><a name="l00832"></a><span class="lineno">  832</span>&#160;Main evaluation operator (some lines broken up for clarity) {#listingmaineval}</div><div class="line"><a name="l00833"></a><span class="lineno">  833</span>&#160;----------------------------------------------------------</div><div class="line"><a name="l00834"></a><span class="lineno">  834</span>&#160;</div><div class="line"><a name="l00835"></a><span class="lineno">  835</span>&#160;```{.cpp}</div><div class="line"><a name="l00836"></a><span class="lineno">  836</span>&#160;__device__ fptype MetricTaker::operator () </div><div class="line"><a name="l00837"></a><span class="lineno">  837</span>&#160;  (thrust::tuple&lt;int, fptype*, int&gt; t) const {</div><div class="line"><a name="l00838"></a><span class="lineno">  838</span>&#160;  // Calculate event offset for this thread. </div><div class="line"><a name="l00839"></a><span class="lineno">  839</span>&#160;  int eventIndex = thrust::get&lt;0&gt;(t);</div><div class="line"><a name="l00840"></a><span class="lineno">  840</span>&#160;  int eventSize  = thrust::get&lt;2&gt;(t);</div><div class="line"><a name="l00841"></a><span class="lineno">  841</span>&#160;  fptype* eventAddress = thrust::get&lt;1&gt;(t);</div><div class="line"><a name="l00842"></a><span class="lineno">  842</span>&#160;  eventAddress += (eventIndex * abs(eventSize)); </div><div class="line"><a name="l00843"></a><span class="lineno">  843</span>&#160;</div><div class="line"><a name="l00844"></a><span class="lineno">  844</span>&#160;  // Causes stack size to be statically undeterminable.</div><div class="line"><a name="l00845"></a><span class="lineno">  845</span>&#160;  fptype ret = callFunction(eventAddress, functionIdx, parameters);</div><div class="line"><a name="l00846"></a><span class="lineno">  846</span>&#160;</div><div class="line"><a name="l00847"></a><span class="lineno">  847</span>&#160;  // Notice assumption here! For unbinned fits the </div><div class="line"><a name="l00848"></a><span class="lineno">  848</span>&#160;  // eventAddress pointer won&#39;t be used in the metric, </div><div class="line"><a name="l00849"></a><span class="lineno">  849</span>&#160;  // so it doesn&#39;t matter what it is. For binned fits it </div><div class="line"><a name="l00850"></a><span class="lineno">  850</span>&#160;  // is assumed that the structure of the event is </div><div class="line"><a name="l00851"></a><span class="lineno">  851</span>&#160;  // (obs1 obs2... binentry binvolume), so that the array</div><div class="line"><a name="l00852"></a><span class="lineno">  852</span>&#160;  // passed to the metric consists of (binentry binvolume). </div><div class="line"><a name="l00853"></a><span class="lineno">  853</span>&#160;  void* fcnAddr = device_function_table[metricIndex];</div><div class="line"><a name="l00854"></a><span class="lineno">  854</span>&#160;  device_metric_ptr fcnPtr;</div><div class="line"><a name="l00855"></a><span class="lineno">  855</span>&#160;  fcnPtr = reinterpret_cast&lt;device_metric_ptr&gt;(fcnAddr);</div><div class="line"><a name="l00856"></a><span class="lineno">  856</span>&#160;  eventAddress += abs(eventSize)-2;</div><div class="line"><a name="l00857"></a><span class="lineno">  857</span>&#160;  ret = (*fcnPtr)(ret, eventAddress, parameters);</div><div class="line"><a name="l00858"></a><span class="lineno">  858</span>&#160;  return ret; </div><div class="line"><a name="l00859"></a><span class="lineno">  859</span>&#160;}</div><div class="line"><a name="l00860"></a><span class="lineno">  860</span>&#160;```</div><div class="line"><a name="l00861"></a><span class="lineno">  861</span>&#160;</div><div class="line"><a name="l00862"></a><span class="lineno">  862</span>&#160;Observe that, for binned events, `eventSize` is negative; in this case</div><div class="line"><a name="l00863"></a><span class="lineno">  863</span>&#160;the event array looks like `x1 y1 n1 v1 x2 y2 n2 v2 ... xN yN nN vN`</div><div class="line"><a name="l00864"></a><span class="lineno">  864</span>&#160;where `x` and `y` are bin centers, `n` is the number of entries, and `v`</div><div class="line"><a name="l00865"></a><span class="lineno">  865</span>&#160;is the bin volume or error. This does not matter for the PDF evaluation</div><div class="line"><a name="l00866"></a><span class="lineno">  866</span>&#160;invoked by `callFunction`, which will just get a pointer to the start of</div><div class="line"><a name="l00867"></a><span class="lineno">  867</span>&#160;the event and read off the bin centers as event variables; hence the</div><div class="line"><a name="l00868"></a><span class="lineno">  868</span>&#160;`abs(eventSize)` in the calculation of the event address allows binned</div><div class="line"><a name="l00869"></a><span class="lineno">  869</span>&#160;and unbinned PDFs to be treated the same. However, it very much does</div><div class="line"><a name="l00870"></a><span class="lineno">  870</span>&#160;matter for the goodness-of-fit metric. Suppose the fit is the default</div><div class="line"><a name="l00871"></a><span class="lineno">  871</span>&#160;NLL: Then all the operator needs to do at this point is take the</div><div class="line"><a name="l00872"></a><span class="lineno">  872</span>&#160;logarithm of what the PDF returned, multiply by -2, and be on its way.</div><div class="line"><a name="l00873"></a><span class="lineno">  873</span>&#160;But if it is a chi-square fit, then it must calculate the expected</div><div class="line"><a name="l00874"></a><span class="lineno">  874</span>&#160;number of hits in the bin, which depends on the PDF value, the bin</div><div class="line"><a name="l00875"></a><span class="lineno">  875</span>&#160;volume, and the total number of events (\ref footnote8 &quot;8&quot;), subtract the observed</div><div class="line"><a name="l00876"></a><span class="lineno">  876</span>&#160;number, square, and divide by the observed number. Hence there is a</div><div class="line"><a name="l00877"></a><span class="lineno">  877</span>&#160;second function-pointer lookup, but now the `void*` stored in</div><div class="line"><a name="l00878"></a><span class="lineno">  878</span>&#160;`device_function_table` is to be interpreted as a different kind of</div><div class="line"><a name="l00879"></a><span class="lineno">  879</span>&#160;function - a “take the metric” function rather than a “calculate the</div><div class="line"><a name="l00880"></a><span class="lineno">  880</span>&#160;PDF” function. The `metricIndex` member of `MetricTaker` is set by the</div><div class="line"><a name="l00881"></a><span class="lineno">  881</span>&#160;`FitControl` object of the PDF; it points to one of the `calculateFoo`</div><div class="line"><a name="l00882"></a><span class="lineno">  882</span>&#160;functions:</div><div class="line"><a name="l00883"></a><span class="lineno">  883</span>&#160;</div><div class="line"><a name="l00884"></a><span class="lineno">  884</span>&#160;Metric-taking functions {#listingmetrics}</div><div class="line"><a name="l00885"></a><span class="lineno">  885</span>&#160;-------</div><div class="line"><a name="l00886"></a><span class="lineno">  886</span>&#160;</div><div class="line"><a name="l00887"></a><span class="lineno">  887</span>&#160;```{.cpp}</div><div class="line"><a name="l00888"></a><span class="lineno">  888</span>&#160;__device__ fptype calculateEval (fptype rawPdf, </div><div class="line"><a name="l00889"></a><span class="lineno">  889</span>&#160;                                 fptype* evtVal, </div><div class="line"><a name="l00890"></a><span class="lineno">  890</span>&#160;                                 unsigned int par) {</div><div class="line"><a name="l00891"></a><span class="lineno">  891</span>&#160;  // Just return the raw PDF value, for use </div><div class="line"><a name="l00892"></a><span class="lineno">  892</span>&#160;  // in (eg) normalisation. </div><div class="line"><a name="l00893"></a><span class="lineno">  893</span>&#160;  return rawPdf; </div><div class="line"><a name="l00894"></a><span class="lineno">  894</span>&#160;}</div><div class="line"><a name="l00895"></a><span class="lineno">  895</span>&#160;</div><div class="line"><a name="l00896"></a><span class="lineno">  896</span>&#160;__device__ fptype calculateNLL (fptype rawPdf, </div><div class="line"><a name="l00897"></a><span class="lineno">  897</span>&#160;                                 fptype* evtVal, </div><div class="line"><a name="l00898"></a><span class="lineno">  898</span>&#160;                                 unsigned int par) {</div><div class="line"><a name="l00899"></a><span class="lineno">  899</span>&#160;  rawPdf *= normalisationFactors[par];</div><div class="line"><a name="l00900"></a><span class="lineno">  900</span>&#160;  return rawPdf &gt; 0 ? -log(rawPdf) : 0; </div><div class="line"><a name="l00901"></a><span class="lineno">  901</span>&#160;}</div><div class="line"><a name="l00902"></a><span class="lineno">  902</span>&#160;</div><div class="line"><a name="l00903"></a><span class="lineno">  903</span>&#160;__device__ fptype calculateProb (fptype rawPdf, </div><div class="line"><a name="l00904"></a><span class="lineno">  904</span>&#160;                                 fptype* evtVal, </div><div class="line"><a name="l00905"></a><span class="lineno">  905</span>&#160;                                 unsigned int par) {</div><div class="line"><a name="l00906"></a><span class="lineno">  906</span>&#160;  // Return probability, ie normalized PDF value.</div><div class="line"><a name="l00907"></a><span class="lineno">  907</span>&#160;  return rawPdf * normalisationFactors[par];</div><div class="line"><a name="l00908"></a><span class="lineno">  908</span>&#160;}</div><div class="line"><a name="l00909"></a><span class="lineno">  909</span>&#160;</div><div class="line"><a name="l00910"></a><span class="lineno">  910</span>&#160;__device__ fptype calculateBinAvg (fptype rawPdf, </div><div class="line"><a name="l00911"></a><span class="lineno">  911</span>&#160;                                 fptype* evtVal, </div><div class="line"><a name="l00912"></a><span class="lineno">  912</span>&#160;                                 unsigned int par) {</div><div class="line"><a name="l00913"></a><span class="lineno">  913</span>&#160;  rawPdf *= normalisationFactors[par];</div><div class="line"><a name="l00914"></a><span class="lineno">  914</span>&#160;  rawPdf *= evtVal[1]; // Bin volume </div><div class="line"><a name="l00915"></a><span class="lineno">  915</span>&#160;  // Log-likelihood of numEvents with expectation of exp </div><div class="line"><a name="l00916"></a><span class="lineno">  916</span>&#160;  // is (-exp + numEvents*ln(exp) - ln(numEvents!)). </div><div class="line"><a name="l00917"></a><span class="lineno">  917</span>&#160;  // The last is constant, so we drop it; and then multiply </div><div class="line"><a name="l00918"></a><span class="lineno">  918</span>&#160;  // by minus one to get the negative log-likelihood. </div><div class="line"><a name="l00919"></a><span class="lineno">  919</span>&#160;  if (rawPdf &gt; 0) {</div><div class="line"><a name="l00920"></a><span class="lineno">  920</span>&#160;    fptype expEvents = functorConstants[0]*rawPdf;</div><div class="line"><a name="l00921"></a><span class="lineno">  921</span>&#160;    return (expEvents - evtVal[0]*log(expEvents)); </div><div class="line"><a name="l00922"></a><span class="lineno">  922</span>&#160;  }</div><div class="line"><a name="l00923"></a><span class="lineno">  923</span>&#160;  return 0; </div><div class="line"><a name="l00924"></a><span class="lineno">  924</span>&#160;}</div><div class="line"><a name="l00925"></a><span class="lineno">  925</span>&#160;</div><div class="line"><a name="l00926"></a><span class="lineno">  926</span>&#160;__device__ fptype calculateBinWithError (fptype rawPdf, </div><div class="line"><a name="l00927"></a><span class="lineno">  927</span>&#160;                                 fptype* evtVal, </div><div class="line"><a name="l00928"></a><span class="lineno">  928</span>&#160;                                 unsigned int par) {</div><div class="line"><a name="l00929"></a><span class="lineno">  929</span>&#160;  // In this case interpret the rawPdf as just a number, </div><div class="line"><a name="l00930"></a><span class="lineno">  930</span>&#160;  // not a number of events. Do not divide by integral over </div><div class="line"><a name="l00931"></a><span class="lineno">  931</span>&#160;  // phase space, do not multiply by bin volume, and do not </div><div class="line"><a name="l00932"></a><span class="lineno">  932</span>&#160;  // collect 200 dollars. evtVal should have the structure </div><div class="line"><a name="l00933"></a><span class="lineno">  933</span>&#160;  // (bin entry, bin error). </div><div class="line"><a name="l00934"></a><span class="lineno">  934</span>&#160;  rawPdf -= evtVal[0]; // Subtract observed value.</div><div class="line"><a name="l00935"></a><span class="lineno">  935</span>&#160;  rawPdf /= evtVal[1]; // Divide by error.</div><div class="line"><a name="l00936"></a><span class="lineno">  936</span>&#160;  rawPdf *= rawPdf; </div><div class="line"><a name="l00937"></a><span class="lineno">  937</span>&#160;  return rawPdf; </div><div class="line"><a name="l00938"></a><span class="lineno">  938</span>&#160;}</div><div class="line"><a name="l00939"></a><span class="lineno">  939</span>&#160;</div><div class="line"><a name="l00940"></a><span class="lineno">  940</span>&#160;__device__ fptype calculateChisq (fptype rawPdf, </div><div class="line"><a name="l00941"></a><span class="lineno">  941</span>&#160;                                 fptype* evtVal, </div><div class="line"><a name="l00942"></a><span class="lineno">  942</span>&#160;                                 unsigned int par) {</div><div class="line"><a name="l00943"></a><span class="lineno">  943</span>&#160;  rawPdf *= normalisationFactors[par];</div><div class="line"><a name="l00944"></a><span class="lineno">  944</span>&#160;  rawPdf *= evtVal[1]; // Bin volume </div><div class="line"><a name="l00945"></a><span class="lineno">  945</span>&#160;</div><div class="line"><a name="l00946"></a><span class="lineno">  946</span>&#160;  fptype ret = pow(rawPdf * functorConstants[0] - evtVal[0], 2);</div><div class="line"><a name="l00947"></a><span class="lineno">  947</span>&#160;  ret /= (evtVal[0] &gt; 1 ? evtVal[0] : 1); </div><div class="line"><a name="l00948"></a><span class="lineno">  948</span>&#160;  return ret;</div><div class="line"><a name="l00949"></a><span class="lineno">  949</span>&#160;}</div><div class="line"><a name="l00950"></a><span class="lineno">  950</span>&#160;```</div><div class="line"><a name="l00951"></a><span class="lineno">  951</span>&#160;</div><div class="line"><a name="l00952"></a><span class="lineno">  952</span>&#160;Notice the use of `normalisationFactors` in most of the metric</div><div class="line"><a name="l00953"></a><span class="lineno">  953</span>&#160;functions, and the special cases when the PDF or the observed number of</div><div class="line"><a name="l00954"></a><span class="lineno">  954</span>&#160;events is zero.</div><div class="line"><a name="l00955"></a><span class="lineno">  955</span>&#160;</div><div class="line"><a name="l00956"></a><span class="lineno">  956</span>&#160;It is worth noting that the PDF evaluation function may itself call</div><div class="line"><a name="l00957"></a><span class="lineno">  957</span>&#160;other functions, either using `callFunction` or manually casting a</div><div class="line"><a name="l00958"></a><span class="lineno">  958</span>&#160;function index into other kinds of functions, as in the metric</div><div class="line"><a name="l00959"></a><span class="lineno">  959</span>&#160;calculation of listing [Main Eval](@ref listingmaineval). For example, in</div><div class="line"><a name="l00960"></a><span class="lineno">  960</span>&#160;`DalitzPlotPdf`, each resonance may be parametrised by a relativistic</div><div class="line"><a name="l00961"></a><span class="lineno">  961</span>&#160;Breit-Wigner, a Gaussian, a Flatte function, or more esoteric forms; so</div><div class="line"><a name="l00962"></a><span class="lineno">  962</span>&#160;the main function is supplied with a list of function indices and</div><div class="line"><a name="l00963"></a><span class="lineno">  963</span>&#160;parameter indices for them, and interprets the `void` pointer from</div><div class="line"><a name="l00964"></a><span class="lineno">  964</span>&#160;`device_function_table` as a specialised function type taking</div><div class="line"><a name="l00965"></a><span class="lineno">  965</span>&#160;Dalitz-plot location (rather than a generic event) as its argument. More</div><div class="line"><a name="l00966"></a><span class="lineno">  966</span>&#160;prosaically, `AddPdf` simply carries a list of PDF function indices and</div><div class="line"><a name="l00967"></a><span class="lineno">  967</span>&#160;indices of weights to assign them, and invokes `callFunction` several</div><div class="line"><a name="l00968"></a><span class="lineno">  968</span>&#160;times, multiplying the results by its weight parameters and returning</div><div class="line"><a name="l00969"></a><span class="lineno">  969</span>&#160;the sum.</div><div class="line"><a name="l00970"></a><span class="lineno">  970</span>&#160;</div><div class="line"><a name="l00971"></a><span class="lineno">  971</span>&#160;We have now calculated the function value that we ask MINUIT to</div><div class="line"><a name="l00972"></a><span class="lineno">  972</span>&#160;minimise, for a single set of parameters; this value is passed back to</div><div class="line"><a name="l00973"></a><span class="lineno">  973</span>&#160;MINUIT, which does its thing and comes up with another set of parameters</div><div class="line"><a name="l00974"></a><span class="lineno">  974</span>&#160;for us, completing the loop. Ends here the saga of the fit iteration;</div><div class="line"><a name="l00975"></a><span class="lineno">  975</span>&#160;you now know the entire essential functionality of GooFit’s core engine.</div><div class="line"><a name="l00976"></a><span class="lineno">  976</span>&#160;</div><div class="line"><a name="l00977"></a><span class="lineno">  977</span>&#160;Existing PDF classes</div><div class="line"><a name="l00978"></a><span class="lineno">  978</span>&#160;====================</div><div class="line"><a name="l00979"></a><span class="lineno">  979</span>&#160;</div><div class="line"><a name="l00980"></a><span class="lineno">  980</span>&#160;The GooFit PDFs, like ancient Gaul, are roughly divisible into three:</div><div class="line"><a name="l00981"></a><span class="lineno">  981</span>&#160;</div><div class="line"><a name="l00982"></a><span class="lineno">  982</span>&#160;-   Basic functions, written because they are (expected to be)</div><div class="line"><a name="l00983"></a><span class="lineno">  983</span>&#160;    frequently used, such as the Gaussian and polynomial PDFs.</div><div class="line"><a name="l00984"></a><span class="lineno">  984</span>&#160;</div><div class="line"><a name="l00985"></a><span class="lineno">  985</span>&#160;-   Combiners, functions that take other functions as arguments and spit</div><div class="line"><a name="l00986"></a><span class="lineno">  986</span>&#160;    out some combination of the inputs, for example sums and products.</div><div class="line"><a name="l00987"></a><span class="lineno">  987</span>&#160;</div><div class="line"><a name="l00988"></a><span class="lineno">  988</span>&#160;-   Specialised PDFs, written for the \f$D^0\to\pi\pi\pi^0\f$ mixing</div><div class="line"><a name="l00989"></a><span class="lineno">  989</span>&#160;    analysis that is the driving test case for GooFit’s capabilities.</div><div class="line"><a name="l00990"></a><span class="lineno">  990</span>&#160;</div><div class="line"><a name="l00991"></a><span class="lineno">  991</span>&#160;In the lists below, note that all the constructors take pointers to</div><div class="line"><a name="l00992"></a><span class="lineno">  992</span>&#160;`Variable` objects; rather than repetitively repeat “`Variable` pointer”</div><div class="line"><a name="l00993"></a><span class="lineno">  993</span>&#160;in a redundantly recurring manner, we just say `Variable`. Additionally,</div><div class="line"><a name="l00994"></a><span class="lineno">  994</span>&#160;the first argument in every constructor is the name of the object being</div><div class="line"><a name="l00995"></a><span class="lineno">  995</span>&#160;created; again this is not mentioned in every item. By convention,</div><div class="line"><a name="l00996"></a><span class="lineno">  996</span>&#160;constructors take observables first, then parameters.</div><div class="line"><a name="l00997"></a><span class="lineno">  997</span>&#160;</div><div class="line"><a name="l00998"></a><span class="lineno">  998</span>&#160;Basic PDFs</div><div class="line"><a name="l00999"></a><span class="lineno">  999</span>&#160;----------</div><div class="line"><a name="l01000"></a><span class="lineno"> 1000</span>&#160;</div><div class="line"><a name="l01001"></a><span class="lineno"> 1001</span>&#160;Basic PDFs are relatively straightforward: They take one or more</div><div class="line"><a name="l01002"></a><span class="lineno"> 1002</span>&#160;observables and one or more parameters, and implement operations that</div><div class="line"><a name="l01003"></a><span class="lineno"> 1003</span>&#160;are in some sense ‘atomic’ - they do not combine several functions in</div><div class="line"><a name="l01004"></a><span class="lineno"> 1004</span>&#160;any way. Usually they have a reasonably well-known given name, for</div><div class="line"><a name="l01005"></a><span class="lineno"> 1005</span>&#160;example “the threshold function” or “a polynomial”. The canonical</div><div class="line"><a name="l01006"></a><span class="lineno"> 1006</span>&#160;example is the Gaussian PDF.</div><div class="line"><a name="l01007"></a><span class="lineno"> 1007</span>&#160;</div><div class="line"><a name="l01008"></a><span class="lineno"> 1008</span>&#160;-   `ArgusPdf`: Implements a threshold function </div><div class="line"><a name="l01009"></a><span class="lineno"> 1009</span>&#160;\f{align}{</div><div class="line"><a name="l01010"></a><span class="lineno"> 1010</span>&#160;    P(x;m_0,a,p) &amp;=&amp; \left\{ \begin{matrix}</div><div class="line"><a name="l01011"></a><span class="lineno"> 1011</span>&#160;    0 &amp; x \le m_0 \\</div><div class="line"><a name="l01012"></a><span class="lineno"> 1012</span>&#160;    x\left(\frac{x^2-m_0^2}{m_0^2}\right)^p e^{a\frac{x^2-m_0^2}{m_0^2}} &amp; x &gt; m_0 \\</div><div class="line"><a name="l01013"></a><span class="lineno"> 1013</span>&#160;    \end{matrix}</div><div class="line"><a name="l01014"></a><span class="lineno"> 1014</span>&#160;    \right. </div><div class="line"><a name="l01015"></a><span class="lineno"> 1015</span>&#160;\f} where the power \f$p\f$ is, by default, fixed at</div><div class="line"><a name="l01016"></a><span class="lineno"> 1016</span>&#160;    0.5. The constructor takes `Variable`s representing \f$x\f$, \f$m_0\f$, and</div><div class="line"><a name="l01017"></a><span class="lineno"> 1017</span>&#160;    \f$a\f$, followed by a boolean indicating whether the threshold is an</div><div class="line"><a name="l01018"></a><span class="lineno"> 1018</span>&#160;    upper or lower bound. The equation above shows the PDF for a lower</div><div class="line"><a name="l01019"></a><span class="lineno"> 1019</span>&#160;    bound; for upper bounds, \f$x^2-m_0^2\f$ becomes instead \f$m_0^2-x^2\f$,</div><div class="line"><a name="l01020"></a><span class="lineno"> 1020</span>&#160;    and the value is zero above rather than below \f$m_0\f$. The constructor</div><div class="line"><a name="l01021"></a><span class="lineno"> 1021</span>&#160;    also takes an optional `Variable` representing the power \f$p\f$; if not</div><div class="line"><a name="l01022"></a><span class="lineno"> 1022</span>&#160;    given, a default parameter with value 0.5 is created.</div><div class="line"><a name="l01023"></a><span class="lineno"> 1023</span>&#160;</div><div class="line"><a name="l01024"></a><span class="lineno"> 1024</span>&#160;-   `BifurGaussPdf`: A two-sided Gaussian, with a \f$\sigma\f$ that varies</div><div class="line"><a name="l01025"></a><span class="lineno"> 1025</span>&#160;    depending on which side of the mean you are on: </div><div class="line"><a name="l01026"></a><span class="lineno"> 1026</span>&#160;\f{align}{</div><div class="line"><a name="l01027"></a><span class="lineno"> 1027</span>&#160;    P(x;m,\sigma_L,\sigma_R) &amp;=&amp; \left\{ \begin{matrix}</div><div class="line"><a name="l01028"></a><span class="lineno"> 1028</span>&#160;    e^{-\frac{(x-m)^2}{2\sigma_L^2}} &amp; x \le m \\</div><div class="line"><a name="l01029"></a><span class="lineno"> 1029</span>&#160;    e^{-\frac{(x-m)^2}{2\sigma_R^2}} &amp; x &gt; m. \\</div><div class="line"><a name="l01030"></a><span class="lineno"> 1030</span>&#160;    \end{matrix}</div><div class="line"><a name="l01031"></a><span class="lineno"> 1031</span>&#160;    \right. </div><div class="line"><a name="l01032"></a><span class="lineno"> 1032</span>&#160;\f} The constructor takes the observable \f$x\f$,</div><div class="line"><a name="l01033"></a><span class="lineno"> 1033</span>&#160;    mean \f$m\f$, and left and right sigmas \f$\sigma_{L,R}\f$.</div><div class="line"><a name="l01034"></a><span class="lineno"> 1034</span>&#160;</div><div class="line"><a name="l01035"></a><span class="lineno"> 1035</span>&#160;-   `BWPdf`: A non-relativistic Breit-Wigner function, sometimes called</div><div class="line"><a name="l01036"></a><span class="lineno"> 1036</span>&#160;    a Cauchy function: </div><div class="line"><a name="l01037"></a><span class="lineno"> 1037</span>&#160;\f{align}{</div><div class="line"><a name="l01038"></a><span class="lineno"> 1038</span>&#160;    P(x;m,\Gamma) &amp;=&amp; \frac{1}{2\sqrt{\pi}}\frac{\Gamma}{(x-m)^2 + \Gamma^2/4}</div><div class="line"><a name="l01039"></a><span class="lineno"> 1039</span>&#160;\f}</div><div class="line"><a name="l01040"></a><span class="lineno"> 1040</span>&#160;    The constructor takes the observable \f$x\f$, mean \f$m\f$, and width</div><div class="line"><a name="l01041"></a><span class="lineno"> 1041</span>&#160;    \f$\Gamma\f$.</div><div class="line"><a name="l01042"></a><span class="lineno"> 1042</span>&#160;</div><div class="line"><a name="l01043"></a><span class="lineno"> 1043</span>&#160;-   `CorrGaussianPdf`: A correlated Gaussian - that is, a function of</div><div class="line"><a name="l01044"></a><span class="lineno"> 1044</span>&#160;    two variables \f$x\f$ and \f$y\f$, each described by a Gaussian</div><div class="line"><a name="l01045"></a><span class="lineno"> 1045</span>&#160;    distribution, but the width of the \f$y\f$ distribution depends on \f$x\f$:</div><div class="line"><a name="l01046"></a><span class="lineno"> 1046</span>&#160;    </div><div class="line"><a name="l01047"></a><span class="lineno"> 1047</span>&#160;\f{align}{</div><div class="line"><a name="l01048"></a><span class="lineno"> 1048</span>&#160;    P(x,y;\bar x,\sigma_x,\bar y, \sigma_y, k) &amp;=&amp; </div><div class="line"><a name="l01049"></a><span class="lineno"> 1049</span>&#160;    e^{-\frac{(x-\bar x)^2}{2\sigma_x^2}}e^{-\frac{(y-\bar y)^2}{2(1 + k(\frac{x-\bar x}{\sigma_x})^2)\sigma_y^2}}</div><div class="line"><a name="l01050"></a><span class="lineno"> 1050</span>&#160;\f}</div><div class="line"><a name="l01051"></a><span class="lineno"> 1051</span>&#160;    In other words, the effective \f$\sigma_y\f$ grows quadratically in the</div><div class="line"><a name="l01052"></a><span class="lineno"> 1052</span>&#160;    normalized distance from the mean of \f$x\f$, with the quadratic term</div><div class="line"><a name="l01053"></a><span class="lineno"> 1053</span>&#160;    having coefficient \f$k\f$. The constructor takes observables \f$x\f$ and</div><div class="line"><a name="l01054"></a><span class="lineno"> 1054</span>&#160;    \f$y\f$, means and widths \f$\bar x\f$, \f$\sigma_x\f$, \f$\bar y\f$ and \f$\sigma_y\f$,</div><div class="line"><a name="l01055"></a><span class="lineno"> 1055</span>&#160;    and coefficient \f$k\f$. Notice that if \f$k\f$ is zero, the function</div><div class="line"><a name="l01056"></a><span class="lineno"> 1056</span>&#160;    reduces to a product of two Gaussians,</div><div class="line"><a name="l01057"></a><span class="lineno"> 1057</span>&#160;    \f$P(x,y;\bar x,\sigma_x,\bar y, \sigma_y) = G(x;\bar x, \sigma_x)G(y;\bar y, \sigma_y)\f$.</div><div class="line"><a name="l01058"></a><span class="lineno"> 1058</span>&#160;</div><div class="line"><a name="l01059"></a><span class="lineno"> 1059</span>&#160;-   `CrystalBallPdf`: A Gaussian with a power-law tail on one side:</div><div class="line"><a name="l01060"></a><span class="lineno"> 1060</span>&#160;    </div><div class="line"><a name="l01061"></a><span class="lineno"> 1061</span>&#160;\f{align}{</div><div class="line"><a name="l01062"></a><span class="lineno"> 1062</span>&#160;    P(x;m,\sigma,\alpha,p) &amp;=&amp; \left\{ \begin{matrix}</div><div class="line"><a name="l01063"></a><span class="lineno"> 1063</span>&#160;    e^{-\frac{(x-m)^2}{2\sigma^2}} &amp; \mathrm{sg}(\alpha)\frac{x - m}{\sigma} \le \mathrm{sg}(\alpha)\alpha \\</div><div class="line"><a name="l01064"></a><span class="lineno"> 1064</span>&#160;    e^{-\alpha^2/2}\left(\frac{p/\alpha}{p/\alpha - \alpha + \frac{x-m}{\sigma}}\right)^p</div><div class="line"><a name="l01065"></a><span class="lineno"> 1065</span>&#160;    &amp; \mathrm{otherwise } (\alpha\ne 0). \\</div><div class="line"><a name="l01066"></a><span class="lineno"> 1066</span>&#160;    \end{matrix}</div><div class="line"><a name="l01067"></a><span class="lineno"> 1067</span>&#160;    \right. </div><div class="line"><a name="l01068"></a><span class="lineno"> 1068</span>&#160;\f} The constructor takes the observable \f$x\f$,</div><div class="line"><a name="l01069"></a><span class="lineno"> 1069</span>&#160;    the mean \f$m\f$, width \f$\sigma\f$, cutoff \f$\alpha\f$, and power \f$p\f$. Note</div><div class="line"><a name="l01070"></a><span class="lineno"> 1070</span>&#160;    that if \f$\alpha\f$ is negative, the power-law tail is on the right; if</div><div class="line"><a name="l01071"></a><span class="lineno"> 1071</span>&#160;    positive, on the left. For \f$\alpha=0\f$, the function reduces to a</div><div class="line"><a name="l01072"></a><span class="lineno"> 1072</span>&#160;    simple Gaussian in order to avoid \f$p/\alpha\f$ blowing up.</div><div class="line"><a name="l01073"></a><span class="lineno"> 1073</span>&#160;</div><div class="line"><a name="l01074"></a><span class="lineno"> 1074</span>&#160;-   `ExpGausPdf`: An exponential decay convolved with a Gaussian</div><div class="line"><a name="l01075"></a><span class="lineno"> 1075</span>&#160;    resolution: </div><div class="line"><a name="l01076"></a><span class="lineno"> 1076</span>&#160;\f{align}{</div><div class="line"><a name="l01077"></a><span class="lineno"> 1077</span>&#160;    P(t;m,\sigma,\tau) &amp;=&amp; e^{-t/\tau} \otimes e^{-\frac{(t-m)^2}{2\sigma^2}} \\</div><div class="line"><a name="l01078"></a><span class="lineno"> 1078</span>&#160;    &amp;=&amp; (\tau/2)e^{(\tau/2)(2m+\tau\sigma^2-2t}\mathrm{erfc}\left(\frac{m+\tau\sigma^2-t}{\sigma\sqrt{2}}\right)</div><div class="line"><a name="l01079"></a><span class="lineno"> 1079</span>&#160;\f}</div><div class="line"><a name="l01080"></a><span class="lineno"> 1080</span>&#160;    where \f$\mathrm{erfc}\f$ is the complementary error function. The</div><div class="line"><a name="l01081"></a><span class="lineno"> 1081</span>&#160;    constructor takes the observed time \f$t\f$, mean \f$m\f$ and width \f$\sigma\f$</div><div class="line"><a name="l01082"></a><span class="lineno"> 1082</span>&#160;    of the resolution, and lifetime \f$\tau\f$. Note that the original decay</div><div class="line"><a name="l01083"></a><span class="lineno"> 1083</span>&#160;    function is zero for \f$t&lt;0\f$.</div><div class="line"><a name="l01084"></a><span class="lineno"> 1084</span>&#160;</div><div class="line"><a name="l01085"></a><span class="lineno"> 1085</span>&#160;-   `ExpPdf`: A plain exponential, </div><div class="line"><a name="l01086"></a><span class="lineno"> 1086</span>&#160;\f{align}{</div><div class="line"><a name="l01087"></a><span class="lineno"> 1087</span>&#160;    P(x;\alpha, x_0) &amp;=&amp; e^{\alpha(x-x_0)}</div><div class="line"><a name="l01088"></a><span class="lineno"> 1088</span>&#160;\f} taking the</div><div class="line"><a name="l01089"></a><span class="lineno"> 1089</span>&#160;    observable \f$x\f$, exponential constant \f$\alpha\f$, and optional offset</div><div class="line"><a name="l01090"></a><span class="lineno"> 1090</span>&#160;    \f$x_0\f$. If \f$x_0\f$ is not specified it defaults to zero. A variant</div><div class="line"><a name="l01091"></a><span class="lineno"> 1091</span>&#160;    constructor takes, in place of \f$\alpha\f$, a `vector` of coefficients</div><div class="line"><a name="l01092"></a><span class="lineno"> 1092</span>&#160;    (in the order \f$\alpha_0\f$ to \f$\alpha_n\f$) to form a polynomial in the</div><div class="line"><a name="l01093"></a><span class="lineno"> 1093</span>&#160;    exponent: </div><div class="line"><a name="l01094"></a><span class="lineno"> 1094</span>&#160;\f{align}{</div><div class="line"><a name="l01095"></a><span class="lineno"> 1095</span>&#160;    P(x;\alpha_0, \alpha_1, \ldots \alpha_n, x_0) &amp;=&amp; e^{\alpha_0 + \alpha_1(x-x_0) + \alpha_2(x-x_0)^2 + \ldots + \alpha_n(x-x_0)^n}</div><div class="line"><a name="l01096"></a><span class="lineno"> 1096</span>&#160;\f}</div><div class="line"><a name="l01097"></a><span class="lineno"> 1097</span>&#160;    The offset \f$x_0\f$ is again optional and defaults to zero.</div><div class="line"><a name="l01098"></a><span class="lineno"> 1098</span>&#160;</div><div class="line"><a name="l01099"></a><span class="lineno"> 1099</span>&#160;-   `GaussianPdf`: What can I say? It’s a normal distribution, the</div><div class="line"><a name="l01100"></a><span class="lineno"> 1100</span>&#160;    potato of PDFs. Kind of bland, but goes with anything. National</div><div class="line"><a name="l01101"></a><span class="lineno"> 1101</span>&#160;    cuisines have been based on it. </div><div class="line"><a name="l01102"></a><span class="lineno"> 1102</span>&#160;\f{align}{</div><div class="line"><a name="l01103"></a><span class="lineno"> 1103</span>&#160;    P(x;m,\sigma) &amp;=&amp; e^-\frac{(x-m)^2}{2\sigma^2}</div><div class="line"><a name="l01104"></a><span class="lineno"> 1104</span>&#160;\f} The</div><div class="line"><a name="l01105"></a><span class="lineno"> 1105</span>&#160;    constructor takes the observable \f$x\f$, mean \f$m\f$, and width \f$\sigma\f$.</div><div class="line"><a name="l01106"></a><span class="lineno"> 1106</span>&#160;</div><div class="line"><a name="l01107"></a><span class="lineno"> 1107</span>&#160;-   `InterHistPdf`: An interpolating histogram; in one dimension:</div><div class="line"><a name="l01108"></a><span class="lineno"> 1108</span>&#160;    </div><div class="line"><a name="l01109"></a><span class="lineno"> 1109</span>&#160;\f{align}{</div><div class="line"><a name="l01110"></a><span class="lineno"> 1110</span>&#160;    P(x) &amp;=&amp; \frac{f(x, b(x))H[b(x)] + f(x, 1 + b(x))H[b(x) + 1]}{f(x, b(x)) + f(x, 1 + b(x))}</div><div class="line"><a name="l01111"></a><span class="lineno"> 1111</span>&#160;\f}</div><div class="line"><a name="l01112"></a><span class="lineno"> 1112</span>&#160;    where \f$H\f$ is a histogram, \f$H[n]\f$ is the content of its bin with</div><div class="line"><a name="l01113"></a><span class="lineno"> 1113</span>&#160;    index \f$n\f$, \f$b(x)\f$ is a function that returns the bin number that \f$x\f$</div><div class="line"><a name="l01114"></a><span class="lineno"> 1114</span>&#160;    falls into, and \f$f(x, n)\f$ is the distance between \f$x\f$ and the center</div><div class="line"><a name="l01115"></a><span class="lineno"> 1115</span>&#160;    of bin \f$n\f$. In other words, it does linear interpolation between</div><div class="line"><a name="l01116"></a><span class="lineno"> 1116</span>&#160;    bins. However, there are two complicating factors. First, the</div><div class="line"><a name="l01117"></a><span class="lineno"> 1117</span>&#160;    histogram may have up to ten (\ref footnote9 &quot;9&quot;) dimensions. Second, the dimensions</div><div class="line"><a name="l01118"></a><span class="lineno"> 1118</span>&#160;    may be either observables or fit parameters. So, for example,</div><div class="line"><a name="l01119"></a><span class="lineno"> 1119</span>&#160;    suppose we want to fit for the width \f$\sigma\f$ of a Gaussian</div><div class="line"><a name="l01120"></a><span class="lineno"> 1120</span>&#160;    distribution, without using the potato of PDFs. We can do this by</div><div class="line"><a name="l01121"></a><span class="lineno"> 1121</span>&#160;    making a two-dimensional histogram: The \f$x\f$ dimension is the</div><div class="line"><a name="l01122"></a><span class="lineno"> 1122</span>&#160;    observable, the \f$y\f$ is \f$\sigma\f$. Fill the histogram with the value</div><div class="line"><a name="l01123"></a><span class="lineno"> 1123</span>&#160;    of the Gaussian (\ref footnote10 &quot;10&quot;) at each \f$x\f$ given the \f$\sigma\f$ in that bin. Now</div><div class="line"><a name="l01124"></a><span class="lineno"> 1124</span>&#160;    when the fit asks the PDF, “What is your value at \f$x\f$ given this</div><div class="line"><a name="l01125"></a><span class="lineno"> 1125</span>&#160;    \f$\sigma\f$?”, the PDF responds by interpolating linearly between four</div><div class="line"><a name="l01126"></a><span class="lineno"> 1126</span>&#160;    bins - ones that were precalculated with \f$\sigma\f$ values close to</div><div class="line"><a name="l01127"></a><span class="lineno"> 1127</span>&#160;    what the fit is asking about. For the Gaussian this is rather</div><div class="line"><a name="l01128"></a><span class="lineno"> 1128</span>&#160;    un-necessary, but may save some time for computationally expensive</div><div class="line"><a name="l01129"></a><span class="lineno"> 1129</span>&#160;    functions.</div><div class="line"><a name="l01130"></a><span class="lineno"> 1130</span>&#160;</div><div class="line"><a name="l01131"></a><span class="lineno"> 1131</span>&#160;    The constructor takes a `BinnedDataSet` representing the underlying</div><div class="line"><a name="l01132"></a><span class="lineno"> 1132</span>&#160;    histogram, a `vector` of fit parameters, and a `vector` of</div><div class="line"><a name="l01133"></a><span class="lineno"> 1133</span>&#160;    observables.</div><div class="line"><a name="l01134"></a><span class="lineno"> 1134</span>&#160;</div><div class="line"><a name="l01135"></a><span class="lineno"> 1135</span>&#160;-   `JohnsonSUPdf`: Another modified Gaussian. You can eat potatoes a</div><div class="line"><a name="l01136"></a><span class="lineno"> 1136</span>&#160;    lot of different ways: </div><div class="line"><a name="l01137"></a><span class="lineno"> 1137</span>&#160;\f{align}{</div><div class="line"><a name="l01138"></a><span class="lineno"> 1138</span>&#160;    P(x;m,\sigma,\gamma,\delta) &amp;=&amp;</div><div class="line"><a name="l01139"></a><span class="lineno"> 1139</span>&#160;    \frac{\delta}{\sigma\sqrt{2\pi(1+\frac{(x-m)^2}{\sigma^2})}}</div><div class="line"><a name="l01140"></a><span class="lineno"> 1140</span>&#160;    e^{-\frac{1}{2}\left(\gamma + \delta\log(\frac{x-m}{\sigma}+\sqrt{1+\frac{(x-m)^2}{\sigma^2}})\right)^2}</div><div class="line"><a name="l01141"></a><span class="lineno"> 1141</span>&#160;\f}</div><div class="line"><a name="l01142"></a><span class="lineno"> 1142</span>&#160;    The constructor takes the observable \f$x\f$, mean \f$m\f$, width \f$\sigma\f$,</div><div class="line"><a name="l01143"></a><span class="lineno"> 1143</span>&#160;    scale parameter \f$\gamma\f$, and shape parameter \f$\delta\f$.</div><div class="line"><a name="l01144"></a><span class="lineno"> 1144</span>&#160;</div><div class="line"><a name="l01145"></a><span class="lineno"> 1145</span>&#160;-   `KinLimitBWPdf`: A relativistic Breit-Wigner function modified by a</div><div class="line"><a name="l01146"></a><span class="lineno"> 1146</span>&#160;    factor accounting for limited phase space (\ref footnote11 &quot;11&quot;); for example, in the</div><div class="line"><a name="l01147"></a><span class="lineno"> 1147</span>&#160;    decay \f$D^{*+}\to D^0\pi^+\f$, the difference between the \f$D^*\f$ and</div><div class="line"><a name="l01148"></a><span class="lineno"> 1148</span>&#160;    \f$D^0\f$ masses is only slightly more than the pion mass. Consequently,</div><div class="line"><a name="l01149"></a><span class="lineno"> 1149</span>&#160;    the distribution of \f$\Delta m = m(D^*) - m(D^0)\f$ is slightly</div><div class="line"><a name="l01150"></a><span class="lineno"> 1150</span>&#160;    asymmetric: The left side of the peak, where the phase space narrows</div><div class="line"><a name="l01151"></a><span class="lineno"> 1151</span>&#160;    rapidly, is less likely than the right side. </div><div class="line"><a name="l01152"></a><span class="lineno"> 1152</span>&#160;\f{align}{</div><div class="line"><a name="l01153"></a><span class="lineno"> 1153</span>&#160;    P(x;x_0,\Gamma,M,m) &amp;=&amp; \left\{ \begin{matrix}</div><div class="line"><a name="l01154"></a><span class="lineno"> 1154</span>&#160;    0 &amp; \lambda(x_0,M,m) \le 0 \\</div><div class="line"><a name="l01155"></a><span class="lineno"> 1155</span>&#160;    \frac{S(x,x_0,M,m)x_0&#39;\Gamma^2}{\left(x_0&#39;-x&#39;^2\right)^2 + x_0&#39;\Gamma^2S^2(x,x_0,M,m)} &amp; \mathrm{otherwise.}</div><div class="line"><a name="l01156"></a><span class="lineno"> 1156</span>&#160;    \end{matrix}</div><div class="line"><a name="l01157"></a><span class="lineno"> 1157</span>&#160;    \right. </div><div class="line"><a name="l01158"></a><span class="lineno"> 1158</span>&#160;\f} Here priming indicates addition of \f$M\f$, so</div><div class="line"><a name="l01159"></a><span class="lineno"> 1159</span>&#160;    that \f$x&#39;=x+M\f$, \f$x_0&#39;=x_0+M\f$; the phase-space function \f$S\f$ and its</div><div class="line"><a name="l01160"></a><span class="lineno"> 1160</span>&#160;    supporting characters \f$\lambda\f$, \f$p\f$, and \f$b_W\f$ are given by</div><div class="line"><a name="l01161"></a><span class="lineno"> 1161</span>&#160;    </div><div class="line"><a name="l01162"></a><span class="lineno"> 1162</span>&#160;\f{align}{</div><div class="line"><a name="l01163"></a><span class="lineno"> 1163</span>&#160;    S(x,x_0,M,m)   &amp;=&amp; \left(\frac{p(x,M,m)}{p(x_0,M,m)}\right)^3\left(\frac{b_W(x,M,m)}{b_W(x_0,M,m)}\right)^2 \\</div><div class="line"><a name="l01164"></a><span class="lineno"> 1164</span>&#160;    b_W(x,M,m)     &amp;=&amp; \frac{1}{\sqrt{1 + r^2p^2(x,M,m)}}\\</div><div class="line"><a name="l01165"></a><span class="lineno"> 1165</span>&#160;    p(x,M,m)       &amp;=&amp; \sqrt{\lambda(x,M,m)/(2x)}\\</div><div class="line"><a name="l01166"></a><span class="lineno"> 1166</span>&#160;    \lambda(x,M,m) &amp;=&amp; \left(x&#39;^2-(M-m)^2\right)\left(x&#39;^2-(M+m)^2\right).</div><div class="line"><a name="l01167"></a><span class="lineno"> 1167</span>&#160;\f}</div><div class="line"><a name="l01168"></a><span class="lineno"> 1168</span>&#160;    The radius \f$r\f$ that appears in \f$b_W\f$ (which does not stand for</div><div class="line"><a name="l01169"></a><span class="lineno"> 1169</span>&#160;    Breit-Wigner, but Blatt-Weisskopf!) is hardcoded to be 1.6.</div><div class="line"><a name="l01170"></a><span class="lineno"> 1170</span>&#160;</div><div class="line"><a name="l01171"></a><span class="lineno"> 1171</span>&#160;    The constructor takes the observable \f$x\f$, mean \f$x_0\f$, and width</div><div class="line"><a name="l01172"></a><span class="lineno"> 1172</span>&#160;    \f$\Gamma\f$. The large and small masses \f$M\f$ and \f$m\f$, which determine</div><div class="line"><a name="l01173"></a><span class="lineno"> 1173</span>&#160;    the phase space, are by default 1.8645 (the \f$D^0\f$ mass) and 0.13957</div><div class="line"><a name="l01174"></a><span class="lineno"> 1174</span>&#160;    (mass of a charged pion), but can be set with a call to `setMasses`.</div><div class="line"><a name="l01175"></a><span class="lineno"> 1175</span>&#160;    Note that they are constants, not fit parameters.</div><div class="line"><a name="l01176"></a><span class="lineno"> 1176</span>&#160;</div><div class="line"><a name="l01177"></a><span class="lineno"> 1177</span>&#160;-   `LandauPdf`: A shape with a long right-hand tail - so long, in fact,</div><div class="line"><a name="l01178"></a><span class="lineno"> 1178</span>&#160;    that its moments are not defined. If the most probable value (note</div><div class="line"><a name="l01179"></a><span class="lineno"> 1179</span>&#160;    that this is not a mean) and the width are taken as 0 and 1, the PDF</div><div class="line"><a name="l01180"></a><span class="lineno"> 1180</span>&#160;    is </div><div class="line"><a name="l01181"></a><span class="lineno"> 1181</span>&#160;\f{align}{</div><div class="line"><a name="l01182"></a><span class="lineno"> 1182</span>&#160;    P(x) &amp;=&amp; \frac{1}{\pi}\int_0^\infty e^{-t\log t - xt}\sin(t\pi)\mathrm{d}t</div><div class="line"><a name="l01183"></a><span class="lineno"> 1183</span>&#160;\f}</div><div class="line"><a name="l01184"></a><span class="lineno"> 1184</span>&#160;    but the GooFit implementation is a lookup table stolen from CERNLIB.</div><div class="line"><a name="l01185"></a><span class="lineno"> 1185</span>&#160;    The constructor takes the observable \f$x\f$, most probable value \f$\mu\f$</div><div class="line"><a name="l01186"></a><span class="lineno"> 1186</span>&#160;    (which shifts the above expression) and the width \f$\sigma\f$ (which</div><div class="line"><a name="l01187"></a><span class="lineno"> 1187</span>&#160;    scales it).</div><div class="line"><a name="l01188"></a><span class="lineno"> 1188</span>&#160;</div><div class="line"><a name="l01189"></a><span class="lineno"> 1189</span>&#160;-   `NovosibirskPdf`: A custom shape with a long tail: </div><div class="line"><a name="l01190"></a><span class="lineno"> 1190</span>&#160;\f{align}{</div><div class="line"><a name="l01191"></a><span class="lineno"> 1191</span>&#160;    P(x;m,\sigma,t) &amp;=&amp; </div><div class="line"><a name="l01192"></a><span class="lineno"> 1192</span>&#160;    e^{-\frac{1}{2}\left(\log^2(1+t\frac{x-m}{\sigma}\frac{\sinh(t\sqrt{\log(4)})}{\sqrt{\log(4)}})/t + t^2\right)}</div><div class="line"><a name="l01193"></a><span class="lineno"> 1193</span>&#160;\f}</div><div class="line"><a name="l01194"></a><span class="lineno"> 1194</span>&#160;    The constructor takes the observable \f$x\f$, mean \f$m\f$, width \f$\sigma\f$,</div><div class="line"><a name="l01195"></a><span class="lineno"> 1195</span>&#160;    and tail factor \f$t\f$. If \f$t\f$ is less than \f$10^{-7}\f$, the function</div><div class="line"><a name="l01196"></a><span class="lineno"> 1196</span>&#160;    returns a simple Gaussian, which probably indicates that it</div><div class="line"><a name="l01197"></a><span class="lineno"> 1197</span>&#160;    approximates a Gaussian for small tail parameters, but I’d hate to</div><div class="line"><a name="l01198"></a><span class="lineno"> 1198</span>&#160;    have to show such a thing.</div><div class="line"><a name="l01199"></a><span class="lineno"> 1199</span>&#160;</div><div class="line"><a name="l01200"></a><span class="lineno"> 1200</span>&#160;-   `PolynomialPdf`: If the Gaussian is the potato, what is the</div><div class="line"><a name="l01201"></a><span class="lineno"> 1201</span>&#160;    polynomial? Bread? Milk? Nothing exotic, at any rate. The GooFit</div><div class="line"><a name="l01202"></a><span class="lineno"> 1202</span>&#160;    version does have some subtleties, to allow for polynomials over an</div><div class="line"><a name="l01203"></a><span class="lineno"> 1203</span>&#160;    arbitrary number (\ref footnote12 &quot;12&quot;) of dimensions: </div><div class="line"><a name="l01204"></a><span class="lineno"> 1204</span>&#160;\f{align}{</div><div class="line"><a name="l01205"></a><span class="lineno"> 1205</span>&#160;    P(\vec x; \vec a, \vec x_0, N) &amp;=&amp;</div><div class="line"><a name="l01206"></a><span class="lineno"> 1206</span>&#160;    \sum\limits_{p_1+p_2+\ldots+p_n \le N} a_{p_1p_2\ldots p_n} \prod\limits_{i=1}^n (\vec x - \vec x_0)_i^{p_i}</div><div class="line"><a name="l01207"></a><span class="lineno"> 1207</span>&#160;\f}</div><div class="line"><a name="l01208"></a><span class="lineno"> 1208</span>&#160;    where \f$N\f$ is the highest degree of the polynomial and \f$n\f$ is the</div><div class="line"><a name="l01209"></a><span class="lineno"> 1209</span>&#160;    number of dimensions. The constructor takes a `vector` of</div><div class="line"><a name="l01210"></a><span class="lineno"> 1210</span>&#160;    observables, denoted \f$\vec x\f$ above; a `vector` of coefficients,</div><div class="line"><a name="l01211"></a><span class="lineno"> 1211</span>&#160;    \f$\vec a\f$, a `vector` of optional offsets \f$\vec x_0\f$ (if not</div><div class="line"><a name="l01212"></a><span class="lineno"> 1212</span>&#160;    specified, these default to zero), and the maximum degree \f$N\f$. The</div><div class="line"><a name="l01213"></a><span class="lineno"> 1213</span>&#160;    coefficients are in the order</div><div class="line"><a name="l01214"></a><span class="lineno"> 1214</span>&#160;    \f$a_{p_0p_0\ldots p_0}, a_{p_1p_0\ldots p_0}, \ldots a_{p_Np_0\ldots p_0}, a_{p_0p_1\ldots p_0}, a_{p_1p_1\ldots p_0}, </div><div class="line"><a name="l01215"></a><span class="lineno"> 1215</span>&#160;    \ldots a_{p_0p_0\ldots p_N}\f$. In other words, start at the index for</div><div class="line"><a name="l01216"></a><span class="lineno"> 1216</span>&#160;    the constant term, and increment the power of the leftmost</div><div class="line"><a name="l01217"></a><span class="lineno"> 1217</span>&#160;    observable. Every time the sum of the powers reaches \f$N\f$, reset the</div><div class="line"><a name="l01218"></a><span class="lineno"> 1218</span>&#160;    leftmost power to zero and increment the next-leftmost. When the</div><div class="line"><a name="l01219"></a><span class="lineno"> 1219</span>&#160;    next-leftmost reaches \f$N\f$, reset it to zero and increment the</div><div class="line"><a name="l01220"></a><span class="lineno"> 1220</span>&#160;    third-leftmost, and so on. An example may be helpful; for two</div><div class="line"><a name="l01221"></a><span class="lineno"> 1221</span>&#160;    dimensions \f$x\f$ and \f$y\f$, and a maximum power of 3, the order is</div><div class="line"><a name="l01222"></a><span class="lineno"> 1222</span>&#160;    \f$a_{00}, a_{10}, a_{20}, a_{30}, a_{01}, a_{11}, a_{21}, a_{02}, a_{12}, a_{03}\f$.</div><div class="line"><a name="l01223"></a><span class="lineno"> 1223</span>&#160;    This can be visualised as picking boxes out of a matrix and</div><div class="line"><a name="l01224"></a><span class="lineno"> 1224</span>&#160;    discarding the ones where the powers exceed the maximum:</div><div class="line"><a name="l01225"></a><span class="lineno"> 1225</span>&#160;    </div><div class="line"><a name="l01226"></a><span class="lineno"> 1226</span>&#160;\f[</div><div class="line"><a name="l01227"></a><span class="lineno"> 1227</span>&#160;\begin{array}{cccc}</div><div class="line"><a name="l01228"></a><span class="lineno"> 1228</span>&#160;    9: x^0y^3 &amp;    -      &amp;    -      &amp;    -      \\</div><div class="line"><a name="l01229"></a><span class="lineno"> 1229</span>&#160;    7: x^0y^2 &amp; 8: x^1y^2 &amp;    -      &amp;    -      \\</div><div class="line"><a name="l01230"></a><span class="lineno"> 1230</span>&#160;    4: x^0y^1 &amp; 5: x^1y^1 &amp; 6: x^2y^1 &amp;    -      \\</div><div class="line"><a name="l01231"></a><span class="lineno"> 1231</span>&#160;    0: x^0y^0 &amp; 1: x^1y^0 &amp; 2: x^2y^0 &amp; 3: x^3y^0 \\</div><div class="line"><a name="l01232"></a><span class="lineno"> 1232</span>&#160;\end{array}</div><div class="line"><a name="l01233"></a><span class="lineno"> 1233</span>&#160;\f]</div><div class="line"><a name="l01234"></a><span class="lineno"> 1234</span>&#160; starting in the lower-lefthand corner and going right,</div><div class="line"><a name="l01235"></a><span class="lineno"> 1235</span>&#160;    then up.</div><div class="line"><a name="l01236"></a><span class="lineno"> 1236</span>&#160;</div><div class="line"><a name="l01237"></a><span class="lineno"> 1237</span>&#160;    There is also a simpler version of the constructor for the case of a</div><div class="line"><a name="l01238"></a><span class="lineno"> 1238</span>&#160;    polynomial with only one dimension; it takes the observable, a</div><div class="line"><a name="l01239"></a><span class="lineno"> 1239</span>&#160;    `vector` of coefficients, an optional offset, and the lowest (not</div><div class="line"><a name="l01240"></a><span class="lineno"> 1240</span>&#160;    highest) degree of the polynomial; the latter two both default to</div><div class="line"><a name="l01241"></a><span class="lineno"> 1241</span>&#160;    zero. In this case the order of the coefficients is from lowest to</div><div class="line"><a name="l01242"></a><span class="lineno"> 1242</span>&#160;    highest power.</div><div class="line"><a name="l01243"></a><span class="lineno"> 1243</span>&#160;</div><div class="line"><a name="l01244"></a><span class="lineno"> 1244</span>&#160;-   `ScaledGaussianPdf`: Another Gaussian variant. This one moves its</div><div class="line"><a name="l01245"></a><span class="lineno"> 1245</span>&#160;    mean by a bias \f$b\f$ and scales its width by a scale factor</div><div class="line"><a name="l01246"></a><span class="lineno"> 1246</span>&#160;    \f$\epsilon\f$: </div><div class="line"><a name="l01247"></a><span class="lineno"> 1247</span>&#160;\f{align}{</div><div class="line"><a name="l01248"></a><span class="lineno"> 1248</span>&#160;    P(x;m,\sigma,b,\epsilon) &amp;=&amp; e^{-\frac{(x+b-m)^2}{2(\sigma(1+\epsilon))^2}}.</div><div class="line"><a name="l01249"></a><span class="lineno"> 1249</span>&#160;\f}</div><div class="line"><a name="l01250"></a><span class="lineno"> 1250</span>&#160;    This has a somewhat specialised function: It allows fitting Monte</div><div class="line"><a name="l01251"></a><span class="lineno"> 1251</span>&#160;    Carlo to, for example, a sum of two Gaussians, whose means and</div><div class="line"><a name="l01252"></a><span class="lineno"> 1252</span>&#160;    widths are then frozen. Then real data can be fit for a common bias</div><div class="line"><a name="l01253"></a><span class="lineno"> 1253</span>&#160;    and \f$\epsilon\f$.</div><div class="line"><a name="l01254"></a><span class="lineno"> 1254</span>&#160;</div><div class="line"><a name="l01255"></a><span class="lineno"> 1255</span>&#160;    The constructor takes the observable \f$x\f$, mean \f$m\f$, width \f$\sigma\f$,</div><div class="line"><a name="l01256"></a><span class="lineno"> 1256</span>&#160;    bias \f$b\f$ and scale factor \f$\epsilon\f$.</div><div class="line"><a name="l01257"></a><span class="lineno"> 1257</span>&#160;</div><div class="line"><a name="l01258"></a><span class="lineno"> 1258</span>&#160;-   `SmoothHistogramPdf`: Another histogram, but this one does smoothing</div><div class="line"><a name="l01259"></a><span class="lineno"> 1259</span>&#160;    in place of interpolation. That is, suppose the event falls in bin</div><div class="line"><a name="l01260"></a><span class="lineno"> 1260</span>&#160;    \f$N\f$ of a one-dimensional histogram; then the returned value is a</div><div class="line"><a name="l01261"></a><span class="lineno"> 1261</span>&#160;    weighted average of bins \f$N-1\f$, \f$N\f$, and \f$N+1\f$. For multidimensional</div><div class="line"><a name="l01262"></a><span class="lineno"> 1262</span>&#160;    cases the weighted average is over all the neighbouring bins,</div><div class="line"><a name="l01263"></a><span class="lineno"> 1263</span>&#160;    including diagonals: </div><div class="line"><a name="l01264"></a><span class="lineno"> 1264</span>&#160;\f{align}{</div><div class="line"><a name="l01265"></a><span class="lineno"> 1265</span>&#160;    P(\vec x;s;H) &amp;=&amp; \frac{H(\mathrm{bin}(\vec x)) + s\sum\limits_{i=\mathrm{neighbours}}\delta{i}H(i)}{1 + s\sum\limits_{i=\mathrm{neighbours}}\delta{i}}</div><div class="line"><a name="l01266"></a><span class="lineno"> 1266</span>&#160;\f}</div><div class="line"><a name="l01267"></a><span class="lineno"> 1267</span>&#160;    where \f$\delta_i\f$ is zero for bins that fall outside the histogram</div><div class="line"><a name="l01268"></a><span class="lineno"> 1268</span>&#160;    limits, and one otherwise. The constructor takes the underlying</div><div class="line"><a name="l01269"></a><span class="lineno"> 1269</span>&#160;    histogram \f$H\f$ (which also defines the event vector \f$\vec x\f$) and the</div><div class="line"><a name="l01270"></a><span class="lineno"> 1270</span>&#160;    smoothing factor \f$s\f$; notice that if \f$s\f$ is zero, the PDF reduces to</div><div class="line"><a name="l01271"></a><span class="lineno"> 1271</span>&#160;    a simple histogram lookup. The `BinnedDataSet` representing \f$H\f$ may</div><div class="line"><a name="l01272"></a><span class="lineno"> 1272</span>&#160;    be empty; in that case the lookup table should be set later using</div><div class="line"><a name="l01273"></a><span class="lineno"> 1273</span>&#160;    the `copyHistogramToDevice` method.</div><div class="line"><a name="l01274"></a><span class="lineno"> 1274</span>&#160;</div><div class="line"><a name="l01275"></a><span class="lineno"> 1275</span>&#160;-   `StepPdf`: Also known as the Heaviside function. Zero up to a point,</div><div class="line"><a name="l01276"></a><span class="lineno"> 1276</span>&#160;    then 1 after that point: </div><div class="line"><a name="l01277"></a><span class="lineno"> 1277</span>&#160;\f{align}{</div><div class="line"><a name="l01278"></a><span class="lineno"> 1278</span>&#160;    P(x;x_0) &amp;=&amp; \left\{</div><div class="line"><a name="l01279"></a><span class="lineno"> 1279</span>&#160;    \begin{matrix}</div><div class="line"><a name="l01280"></a><span class="lineno"> 1280</span>&#160;    0 &amp; x \le x_0 \\ </div><div class="line"><a name="l01281"></a><span class="lineno"> 1281</span>&#160;    1 &amp; x &gt; x_0 </div><div class="line"><a name="l01282"></a><span class="lineno"> 1282</span>&#160;    \end{matrix}</div><div class="line"><a name="l01283"></a><span class="lineno"> 1283</span>&#160;    \right.</div><div class="line"><a name="l01284"></a><span class="lineno"> 1284</span>&#160;\f} The constructor takes the observable \f$x\f$ and</div><div class="line"><a name="l01285"></a><span class="lineno"> 1285</span>&#160;    threshold \f$x_0\f$.</div><div class="line"><a name="l01286"></a><span class="lineno"> 1286</span>&#160;</div><div class="line"><a name="l01287"></a><span class="lineno"> 1287</span>&#160;-   `VoigtianPdf`: A convolution of a classical Breit-Wigner and a</div><div class="line"><a name="l01288"></a><span class="lineno"> 1288</span>&#160;    Gaussian resolution: </div><div class="line"><a name="l01289"></a><span class="lineno"> 1289</span>&#160;\f{align}{</div><div class="line"><a name="l01290"></a><span class="lineno"> 1290</span>&#160;    P(x;m,\sigma,\Gamma) &amp;=&amp; \int\limits_{-\infty}^\infty\frac{\Gamma}{(t-m)^2-\Gamma^2/4} e^{-\frac{(t-x)^2}{2\sigma^2}}\mathrm{d}t. </div><div class="line"><a name="l01291"></a><span class="lineno"> 1291</span>&#160;\f}</div><div class="line"><a name="l01292"></a><span class="lineno"> 1292</span>&#160;    The actual implementation is a horrible lookup-table-interpolation;</div><div class="line"><a name="l01293"></a><span class="lineno"> 1293</span>&#160;    had Lovecraft been aware of this sort of thing, he would not have</div><div class="line"><a name="l01294"></a><span class="lineno"> 1294</span>&#160;    piffled about writing about mere incomprehensible horrors from the</div><div class="line"><a name="l01295"></a><span class="lineno"> 1295</span>&#160;    depths of time. The constructor takes the observable \f$x\f$, mean \f$m\f$,</div><div class="line"><a name="l01296"></a><span class="lineno"> 1296</span>&#160;    Gaussian resolution width \f$\sigma\f$, and Breit-Wigner width \f$\Gamma\f$.</div><div class="line"><a name="l01297"></a><span class="lineno"> 1297</span>&#160;</div><div class="line"><a name="l01298"></a><span class="lineno"> 1298</span>&#160;Combination PDFs</div><div class="line"><a name="l01299"></a><span class="lineno"> 1299</span>&#160;----------------</div><div class="line"><a name="l01300"></a><span class="lineno"> 1300</span>&#160;</div><div class="line"><a name="l01301"></a><span class="lineno"> 1301</span>&#160;These are the tools that allow GooFit to be more than a collection of</div><div class="line"><a name="l01302"></a><span class="lineno"> 1302</span>&#160;special cases. The most obvious example is a sum of PDFs - without a</div><div class="line"><a name="l01303"></a><span class="lineno"> 1303</span>&#160;class for this, you’d have to write a new PDF every time you added a</div><div class="line"><a name="l01304"></a><span class="lineno"> 1304</span>&#160;Gaussian to your fit.</div><div class="line"><a name="l01305"></a><span class="lineno"> 1305</span>&#160;</div><div class="line"><a name="l01306"></a><span class="lineno"> 1306</span>&#160;-   `AddPdf`: A weighted sum of two or more PDFs. There are two</div><div class="line"><a name="l01307"></a><span class="lineno"> 1307</span>&#160;    variants, ‘extended’ and ‘unextended’. In the extended version the</div><div class="line"><a name="l01308"></a><span class="lineno"> 1308</span>&#160;    weights are interpreted as numbers of events, and \f$N\f$ PDFs have \f$N\f$</div><div class="line"><a name="l01309"></a><span class="lineno"> 1309</span>&#160;    weights; in the unextended version the weights are probabilities</div><div class="line"><a name="l01310"></a><span class="lineno"> 1310</span>&#160;    (i.e., between 0 and 1) and \f$N\f$ PDFs have \f$N-1\f$ weights, with the</div><div class="line"><a name="l01311"></a><span class="lineno"> 1311</span>&#160;    probability of the last PDF being 1 minus the sum of the weights of</div><div class="line"><a name="l01312"></a><span class="lineno"> 1312</span>&#160;    the others. </div><div class="line"><a name="l01313"></a><span class="lineno"> 1313</span>&#160;\f{align}{</div><div class="line"><a name="l01314"></a><span class="lineno"> 1314</span>&#160;    P(F_1,\ldots, F_n,w_1,\ldots,w_n) &amp;=&amp; w_1F_1 + \ldots + w_nF_n \\</div><div class="line"><a name="l01315"></a><span class="lineno"> 1315</span>&#160;    P(F_1,\ldots, F_n,w_1,\ldots,w_{n-1}) &amp;=&amp; </div><div class="line"><a name="l01316"></a><span class="lineno"> 1316</span>&#160;    w_1F_1 + \ldots + w_{n-1}F_{n-1}\\</div><div class="line"><a name="l01317"></a><span class="lineno"> 1317</span>&#160;    &amp;&amp;+ (1 - w_1 - \ldots - w_{n-1})F_n.</div><div class="line"><a name="l01318"></a><span class="lineno"> 1318</span>&#160;\f} The constructor</div><div class="line"><a name="l01319"></a><span class="lineno"> 1319</span>&#160;    takes a `vector` of weights \f$w_i\f$ and a `vector` of components</div><div class="line"><a name="l01320"></a><span class="lineno"> 1320</span>&#160;    \f$F_i\f$. If the two `vector`s are of equal length the extended version</div><div class="line"><a name="l01321"></a><span class="lineno"> 1321</span>&#160;    is used; if there is one more component than weight, the unextended</div><div class="line"><a name="l01322"></a><span class="lineno"> 1322</span>&#160;    version; anything else is an error. There is also a special-case</div><div class="line"><a name="l01323"></a><span class="lineno"> 1323</span>&#160;    constructor taking a single weight and two components, to save</div><div class="line"><a name="l01324"></a><span class="lineno"> 1324</span>&#160;    creating the `vector`s in this common case.</div><div class="line"><a name="l01325"></a><span class="lineno"> 1325</span>&#160;</div><div class="line"><a name="l01326"></a><span class="lineno"> 1326</span>&#160;    Note that this PDF overrides the `sumOfNll` method; if an extended</div><div class="line"><a name="l01327"></a><span class="lineno"> 1327</span>&#160;    `AddPdf` is used as a top-level PDF (that is, sent to `FitManager`</div><div class="line"><a name="l01328"></a><span class="lineno"> 1328</span>&#160;    for fitting), an additional term for the number of events will be</div><div class="line"><a name="l01329"></a><span class="lineno"> 1329</span>&#160;    added to the NLL.</div><div class="line"><a name="l01330"></a><span class="lineno"> 1330</span>&#160;</div><div class="line"><a name="l01331"></a><span class="lineno"> 1331</span>&#160;    Also note that if the `AddPdf`’s options mask (set by calling</div><div class="line"><a name="l01332"></a><span class="lineno"> 1332</span>&#160;    `setSpecialMask`) includes `ForceCommonNorm`, the normalisation</div><div class="line"><a name="l01333"></a><span class="lineno"> 1333</span>&#160;    changes. By default the components are normalized separately, so</div><div class="line"><a name="l01334"></a><span class="lineno"> 1334</span>&#160;    that </div><div class="line"><a name="l01335"></a><span class="lineno"> 1335</span>&#160;\f{align}{</div><div class="line"><a name="l01336"></a><span class="lineno"> 1336</span>&#160;    P(x;\vec F, \vec w) &amp;=&amp; \sum\limits_i \frac{w_iF_i(x)}{\int F_i(x) \mathrm{d}x},</div><div class="line"><a name="l01337"></a><span class="lineno"> 1337</span>&#160;\f}</div><div class="line"><a name="l01338"></a><span class="lineno"> 1338</span>&#160;    but with `ForceCommonNorm` set, the integral is instead taken at the</div><div class="line"><a name="l01339"></a><span class="lineno"> 1339</span>&#160;    level of the sum: </div><div class="line"><a name="l01340"></a><span class="lineno"> 1340</span>&#160;\f{align}{</div><div class="line"><a name="l01341"></a><span class="lineno"> 1341</span>&#160;    P(x;\vec F, \vec w) &amp;=&amp; \frac{\sum\limits_i w_iF_i(x)}{\int\sum\limits_i w_iF_i(x)\mathrm{d}x}.</div><div class="line"><a name="l01342"></a><span class="lineno"> 1342</span>&#160;\f}</div><div class="line"><a name="l01343"></a><span class="lineno"> 1343</span>&#160;    The difference is subtle but sometimes important.</div><div class="line"><a name="l01344"></a><span class="lineno"> 1344</span>&#160;</div><div class="line"><a name="l01345"></a><span class="lineno"> 1345</span>&#160;-   `BinTransformPdf`: Returns the global bin of its argument; in one</div><div class="line"><a name="l01346"></a><span class="lineno"> 1346</span>&#160;    dimension: </div><div class="line"><a name="l01347"></a><span class="lineno"> 1347</span>&#160;\f{align}{</div><div class="line"><a name="l01348"></a><span class="lineno"> 1348</span>&#160;    P(x;l,s) &amp;=&amp; \mathrm{floor}\left(\frac{x-l}{s}\right)</div><div class="line"><a name="l01349"></a><span class="lineno"> 1349</span>&#160;\f}</div><div class="line"><a name="l01350"></a><span class="lineno"> 1350</span>&#160;    where \f$l\f$ is the lower limit and \f$s\f$ is the bin size. The utility of</div><div class="line"><a name="l01351"></a><span class="lineno"> 1351</span>&#160;    this is perhaps not immediately obvious; one application is as an</div><div class="line"><a name="l01352"></a><span class="lineno"> 1352</span>&#160;    intermediate step in a `MappedPdf`. For example, suppose I want to</div><div class="line"><a name="l01353"></a><span class="lineno"> 1353</span>&#160;    model a \f$y\f$ distribution with a different set of parameters in five</div><div class="line"><a name="l01354"></a><span class="lineno"> 1354</span>&#160;    slices of \f$x\f$; then I would use a `BinTransformPdf` to calculate</div><div class="line"><a name="l01355"></a><span class="lineno"> 1355</span>&#160;    which slice each event is in.</div><div class="line"><a name="l01356"></a><span class="lineno"> 1356</span>&#160;</div><div class="line"><a name="l01357"></a><span class="lineno"> 1357</span>&#160;    The constructor takes `vector`s of the observables \f$\vec x\f$, lower</div><div class="line"><a name="l01358"></a><span class="lineno"> 1358</span>&#160;    bounds \f$\vec l\f$, bin sizes \f$\vec b\f$, and number of bins \f$\vec n\f$.</div><div class="line"><a name="l01359"></a><span class="lineno"> 1359</span>&#160;    The last is used for converting local (i.e. one-dimensional) bins</div><div class="line"><a name="l01360"></a><span class="lineno"> 1360</span>&#160;    into global bins in the case of multiple dimensions.</div><div class="line"><a name="l01361"></a><span class="lineno"> 1361</span>&#160;</div><div class="line"><a name="l01362"></a><span class="lineno"> 1362</span>&#160;-   `CompositePdf`: A chained function, </div><div class="line"><a name="l01363"></a><span class="lineno"> 1363</span>&#160;\f{align}{</div><div class="line"><a name="l01364"></a><span class="lineno"> 1364</span>&#160;    P(x) &amp;=&amp; h(g(x)).</div><div class="line"><a name="l01365"></a><span class="lineno"> 1365</span>&#160;\f} The constructor takes the kernel</div><div class="line"><a name="l01366"></a><span class="lineno"> 1366</span>&#160;    function \f$g\f$ and the shell function \f$h\f$. Note that only</div><div class="line"><a name="l01367"></a><span class="lineno"> 1367</span>&#160;    one-dimensional composites are supported - \f$h\f$ cannot take more than</div><div class="line"><a name="l01368"></a><span class="lineno"> 1368</span>&#160;    one argument. The core function \f$g\f$ can take any number.</div><div class="line"><a name="l01369"></a><span class="lineno"> 1369</span>&#160;</div><div class="line"><a name="l01370"></a><span class="lineno"> 1370</span>&#160;-   `ConvolutionPdf`: Numerically calculates a convolution integral</div><div class="line"><a name="l01371"></a><span class="lineno"> 1371</span>&#160;    </div><div class="line"><a name="l01372"></a><span class="lineno"> 1372</span>&#160;\f{align}{</div><div class="line"><a name="l01373"></a><span class="lineno"> 1373</span>&#160;    P(x;f,g) &amp;=&amp; f\otimes g = \int\limits_{-\infty}^\infty f(t) g(x-t) \mathrm{d}t.</div><div class="line"><a name="l01374"></a><span class="lineno"> 1374</span>&#160;\f}</div><div class="line"><a name="l01375"></a><span class="lineno"> 1375</span>&#160;    The constructor takes the observable \f$x\f$, model function \f$f\f$, and</div><div class="line"><a name="l01376"></a><span class="lineno"> 1376</span>&#160;    resolution function \f$g\f$.</div><div class="line"><a name="l01377"></a><span class="lineno"> 1377</span>&#160;</div><div class="line"><a name="l01378"></a><span class="lineno"> 1378</span>&#160;    The implementation of this function is a little complicated and</div><div class="line"><a name="l01379"></a><span class="lineno"> 1379</span>&#160;    relies on caching. There is a variant constructor for cases where</div><div class="line"><a name="l01380"></a><span class="lineno"> 1380</span>&#160;    several convolutions may run at the same time, eg a `MappedPdf`</div><div class="line"><a name="l01381"></a><span class="lineno"> 1381</span>&#160;    where all the targets are convolutions. This variant does</div><div class="line"><a name="l01382"></a><span class="lineno"> 1382</span>&#160;    cooperative loading of the caches, which is a *really neat*</div><div class="line"><a name="l01383"></a><span class="lineno"> 1383</span>&#160;    optimisation and ought to work a lot better than it, actually, does.</div><div class="line"><a name="l01384"></a><span class="lineno"> 1384</span>&#160;    Its constructor takes the observable, model, and resolution as</div><div class="line"><a name="l01385"></a><span class="lineno"> 1385</span>&#160;    before, and an integer indicating how many other convolutions are</div><div class="line"><a name="l01386"></a><span class="lineno"> 1386</span>&#160;    going to be using the same cache space.</div><div class="line"><a name="l01387"></a><span class="lineno"> 1387</span>&#160;</div><div class="line"><a name="l01388"></a><span class="lineno"> 1388</span>&#160;-   `EventWeightedAddPdf`: A variant of `AddPdf`, in which the weights</div><div class="line"><a name="l01389"></a><span class="lineno"> 1389</span>&#160;    are not fit parameters but rather observables. It otherwise works</div><div class="line"><a name="l01390"></a><span class="lineno"> 1390</span>&#160;    the same way as `AddPdf`; the constructor takes `vector`s of the</div><div class="line"><a name="l01391"></a><span class="lineno"> 1391</span>&#160;    weights and components, and it has extended and non-extended</div><div class="line"><a name="l01392"></a><span class="lineno"> 1392</span>&#160;    variants. Note that you should not mix-and-match; the weights must</div><div class="line"><a name="l01393"></a><span class="lineno"> 1393</span>&#160;    be either all observables or all fit parameters.</div><div class="line"><a name="l01394"></a><span class="lineno"> 1394</span>&#160;</div><div class="line"><a name="l01395"></a><span class="lineno"> 1395</span>&#160;-   `MappedPdf`: A function having the form </div><div class="line"><a name="l01396"></a><span class="lineno"> 1396</span>&#160;\f{align}{</div><div class="line"><a name="l01397"></a><span class="lineno"> 1397</span>&#160;    F(x) &amp;=&amp; \left\{ \begin{matrix}</div><div class="line"><a name="l01398"></a><span class="lineno"> 1398</span>&#160;    F_1(x)   &amp; x_0 \le x \le x_1 \\</div><div class="line"><a name="l01399"></a><span class="lineno"> 1399</span>&#160;    F_2(x)   &amp; x_1 &lt; x \le x_2 \\</div><div class="line"><a name="l01400"></a><span class="lineno"> 1400</span>&#160;    (\ldots) &amp; (\ldots)        \\</div><div class="line"><a name="l01401"></a><span class="lineno"> 1401</span>&#160;    F_n(x)   &amp; x_{n-1} &lt; x \le x_n \\</div><div class="line"><a name="l01402"></a><span class="lineno"> 1402</span>&#160;    \end{matrix}</div><div class="line"><a name="l01403"></a><span class="lineno"> 1403</span>&#160;    \right. </div><div class="line"><a name="l01404"></a><span class="lineno"> 1404</span>&#160;\f} The constructor takes a *mapping function*</div><div class="line"><a name="l01405"></a><span class="lineno"> 1405</span>&#160;    \f$m\f$, which returns an index; and a `vector` of evaluation functions</div><div class="line"><a name="l01406"></a><span class="lineno"> 1406</span>&#160;    \f$\vec F\f$, so that if \f$m\f$ is zero, the PDF returns \f$F_0\f$, and so on.</div><div class="line"><a name="l01407"></a><span class="lineno"> 1407</span>&#160;    Notice that \f$m\f$ does not strictly need to return an integer - in</div><div class="line"><a name="l01408"></a><span class="lineno"> 1408</span>&#160;    fact the constraints of GooFit force it to return a floating-point</div><div class="line"><a name="l01409"></a><span class="lineno"> 1409</span>&#160;    number - since `MappedPdf` will round the result to the nearest</div><div class="line"><a name="l01410"></a><span class="lineno"> 1410</span>&#160;    whole number. The canonical example of a mapping function is</div><div class="line"><a name="l01411"></a><span class="lineno"> 1411</span>&#160;    `BinTransformPdf`.</div><div class="line"><a name="l01412"></a><span class="lineno"> 1412</span>&#160;</div><div class="line"><a name="l01413"></a><span class="lineno"> 1413</span>&#160;-   `ProdPdf`: A product of two or more PDFs: </div><div class="line"><a name="l01414"></a><span class="lineno"> 1414</span>&#160;\f{align}{</div><div class="line"><a name="l01415"></a><span class="lineno"> 1415</span>&#160;    P(x; \vec F) &amp;=&amp; \prod\limits_i F_i(x).</div><div class="line"><a name="l01416"></a><span class="lineno"> 1416</span>&#160;\f} The</div><div class="line"><a name="l01417"></a><span class="lineno"> 1417</span>&#160;    constructor just takes a `vector` of the functions to be multiplied.</div><div class="line"><a name="l01418"></a><span class="lineno"> 1418</span>&#160;</div><div class="line"><a name="l01419"></a><span class="lineno"> 1419</span>&#160;    `ProdPdf` does allow variable overlaps, that is, the components may</div><div class="line"><a name="l01420"></a><span class="lineno"> 1420</span>&#160;    depend on the same variable, eg \f$P(x) = A(x)B(x)\f$. If this happens,</div><div class="line"><a name="l01421"></a><span class="lineno"> 1421</span>&#160;    the entire `ProdPdf` object will be normalized together, since in</div><div class="line"><a name="l01422"></a><span class="lineno"> 1422</span>&#160;    general</div><div class="line"><a name="l01423"></a><span class="lineno"> 1423</span>&#160;    \f$\int A(x)B(x) \mathrm{d}x \ne \int A(x) \mathrm{d}x \int B(x) \mathrm{d}x\f$.</div><div class="line"><a name="l01424"></a><span class="lineno"> 1424</span>&#160;    However, if any of the components have the flag `ForceSeparateNorm`</div><div class="line"><a name="l01425"></a><span class="lineno"> 1425</span>&#160;    set, as well as in the default case that the components depend on</div><div class="line"><a name="l01426"></a><span class="lineno"> 1426</span>&#160;    separate observables, each component will be normalized</div><div class="line"><a name="l01427"></a><span class="lineno"> 1427</span>&#160;    individually. Some care is indicated when using the</div><div class="line"><a name="l01428"></a><span class="lineno"> 1428</span>&#160;    `ForceSeparateNorm` flag, and possibly a rethink of why there is a</div><div class="line"><a name="l01429"></a><span class="lineno"> 1429</span>&#160;    product of two PDFs depending on the same variable in the first</div><div class="line"><a name="l01430"></a><span class="lineno"> 1430</span>&#160;    place.</div><div class="line"><a name="l01431"></a><span class="lineno"> 1431</span>&#160;</div><div class="line"><a name="l01432"></a><span class="lineno"> 1432</span>&#160;Specialised amplitude-analysis functions</div><div class="line"><a name="l01433"></a><span class="lineno"> 1433</span>&#160;----------------------------------------</div><div class="line"><a name="l01434"></a><span class="lineno"> 1434</span>&#160;</div><div class="line"><a name="l01435"></a><span class="lineno"> 1435</span>&#160;These functions exist mainly for use in a specific physics analysis,</div><div class="line"><a name="l01436"></a><span class="lineno"> 1436</span>&#160;mixing in \f$D^0\to\pi\pi\pi^0\f$. Nonetheless, if you are doing a</div><div class="line"><a name="l01437"></a><span class="lineno"> 1437</span>&#160;Dalitz-plot analysis, you may find them, and conceivably even this</div><div class="line"><a name="l01438"></a><span class="lineno"> 1438</span>&#160;documentation, helpful.</div><div class="line"><a name="l01439"></a><span class="lineno"> 1439</span>&#160;</div><div class="line"><a name="l01440"></a><span class="lineno"> 1440</span>&#160;-   `DalitzPlotPdf`: A time-independent description of the Dalitz plot</div><div class="line"><a name="l01441"></a><span class="lineno"> 1441</span>&#160;    as a coherent sum of resonances: </div><div class="line"><a name="l01442"></a><span class="lineno"> 1442</span>&#160;\f{align}{</div><div class="line"><a name="l01443"></a><span class="lineno"> 1443</span>&#160;    P(m^2_{12},m^2_{13};\vec\alpha) &amp;=&amp; \left|\sum\limits_i \alpha_i B_i(m^2_{12},m^2_{13})\right|^2\epsilon(m^2_{12},m^2_{13})</div><div class="line"><a name="l01444"></a><span class="lineno"> 1444</span>&#160;\f}</div><div class="line"><a name="l01445"></a><span class="lineno"> 1445</span>&#160;    where \f$\alpha_i\f$ is a complex coefficient, \f$B_i\f$ is a resonance</div><div class="line"><a name="l01446"></a><span class="lineno"> 1446</span>&#160;    parametrisation (see `ResonancePdf`, below), and \f$\epsilon\f$ is a</div><div class="line"><a name="l01447"></a><span class="lineno"> 1447</span>&#160;    real-valued efficiency function. The constructor takes the</div><div class="line"><a name="l01448"></a><span class="lineno"> 1448</span>&#160;    squared-mass variables \f$m_{12}\f$ and \f$m_{13}\f$, an event index (this</div><div class="line"><a name="l01449"></a><span class="lineno"> 1449</span>&#160;    is used in caching), a `DecayInfo` object which contains a `vector`</div><div class="line"><a name="l01450"></a><span class="lineno"> 1450</span>&#160;    of `ResonancePdf`s as well as some global information like the</div><div class="line"><a name="l01451"></a><span class="lineno"> 1451</span>&#160;    mother and daughter masses, and the efficiency function.</div><div class="line"><a name="l01452"></a><span class="lineno"> 1452</span>&#160;</div><div class="line"><a name="l01453"></a><span class="lineno"> 1453</span>&#160;-   `DalitzVetoPdf`: Tests whether a point is in a particular region of</div><div class="line"><a name="l01454"></a><span class="lineno"> 1454</span>&#160;    the Dalitz plot, and returns zero if so, one otherwise. Intended for</div><div class="line"><a name="l01455"></a><span class="lineno"> 1455</span>&#160;    use as part of an efficiency function, excluding particular</div><div class="line"><a name="l01456"></a><span class="lineno"> 1456</span>&#160;    regions - canonically the one containing the \f$K^0\to\pi\pi\f$ decay,</div><div class="line"><a name="l01457"></a><span class="lineno"> 1457</span>&#160;    as a large source of backgrounds that proved hard to model. The</div><div class="line"><a name="l01458"></a><span class="lineno"> 1458</span>&#160;    constructor takes the squared-mass variables \f$m_{12}\f$ and \f$m_{13}\f$,</div><div class="line"><a name="l01459"></a><span class="lineno"> 1459</span>&#160;    the masses (contained in `Variable`s) of the mother and three</div><div class="line"><a name="l01460"></a><span class="lineno"> 1460</span>&#160;    daughter particles involved in the decay, and a `vector` of</div><div class="line"><a name="l01461"></a><span class="lineno"> 1461</span>&#160;    `VetoInfo` objects. The `VetoInfo` objects just contain a cyclic</div><div class="line"><a name="l01462"></a><span class="lineno"> 1462</span>&#160;    index (either `PAIR_12`, `PAIR_13`, or `PAIR_23`) and the lower and</div><div class="line"><a name="l01463"></a><span class="lineno"> 1463</span>&#160;    upper bounds of the veto region.</div><div class="line"><a name="l01464"></a><span class="lineno"> 1464</span>&#160;</div><div class="line"><a name="l01465"></a><span class="lineno"> 1465</span>&#160;-   `IncoherentSumPdf`: Similar to `DalitzPlotPdf`, but the resonances</div><div class="line"><a name="l01466"></a><span class="lineno"> 1466</span>&#160;    are added incoherently: </div><div class="line"><a name="l01467"></a><span class="lineno"> 1467</span>&#160;\f{align}{</div><div class="line"><a name="l01468"></a><span class="lineno"> 1468</span>&#160;    P(m^2_{12},m^2_{13};\vec\alpha) &amp;=&amp; \sum\limits_i \left|\alpha_i B_i(m^2_{12},m^2_{13})\right|^2\epsilon(m^2_{12},m^2_{13})</div><div class="line"><a name="l01469"></a><span class="lineno"> 1469</span>&#160;\f}</div><div class="line"><a name="l01470"></a><span class="lineno"> 1470</span>&#160;    The constructor is the same, but note that the `amp_imag` member of</div><div class="line"><a name="l01471"></a><span class="lineno"> 1471</span>&#160;    `ResonancePdf` is not used, so the \f$\alpha\f$ are in effect</div><div class="line"><a name="l01472"></a><span class="lineno"> 1472</span>&#160;    interpreted as real numbers.</div><div class="line"><a name="l01473"></a><span class="lineno"> 1473</span>&#160;</div><div class="line"><a name="l01474"></a><span class="lineno"> 1474</span>&#160;-   `MixingTimeResolution`: (in `MixingTimeResolution_Aux.h`) The abstract base class of</div><div class="line"><a name="l01475"></a><span class="lineno"> 1475</span>&#160;    `TruthResolution` and `ThreeGaussResolution`. Represents a</div><div class="line"><a name="l01476"></a><span class="lineno"> 1476</span>&#160;    parametrisation of the time resolution.</div><div class="line"><a name="l01477"></a><span class="lineno"> 1477</span>&#160;</div><div class="line"><a name="l01478"></a><span class="lineno"> 1478</span>&#160;-   `ResonancePdf`: Represents a resonance-shape parametrisation, the</div><div class="line"><a name="l01479"></a><span class="lineno"> 1479</span>&#160;    \f$B_i\f$ that appear in the equations for `DalitzPlotPdf`,</div><div class="line"><a name="l01480"></a><span class="lineno"> 1480</span>&#160;    `IncoherentSumPdf`, and `TddpPdf`. Canonically a relativistic</div><div class="line"><a name="l01481"></a><span class="lineno"> 1481</span>&#160;    Breit-Wigner. The constructor takes the real and imaginary parts of</div><div class="line"><a name="l01482"></a><span class="lineno"> 1482</span>&#160;    the coefficient \f$\alpha\f$ (note that this is actually used by the</div><div class="line"><a name="l01483"></a><span class="lineno"> 1483</span>&#160;    containing function), and additional parameters depending on which</div><div class="line"><a name="l01484"></a><span class="lineno"> 1484</span>&#160;    function the resonance is modelled by:</div><div class="line"><a name="l01485"></a><span class="lineno"> 1485</span>&#160;</div><div class="line"><a name="l01486"></a><span class="lineno"> 1486</span>&#160;    -   Relativistic Breit-Wigner: Mass, width, spin, and cyclic index.</div><div class="line"><a name="l01487"></a><span class="lineno"> 1487</span>&#160;        The two last are integer constants. Only spins 0, 1, and 2 are</div><div class="line"><a name="l01488"></a><span class="lineno"> 1488</span>&#160;        supported.</div><div class="line"><a name="l01489"></a><span class="lineno"> 1489</span>&#160;</div><div class="line"><a name="l01490"></a><span class="lineno"> 1490</span>&#160;    -   Gounaris-Sakurai parametrisation: Spin, mass, width, and cyclic</div><div class="line"><a name="l01491"></a><span class="lineno"> 1491</span>&#160;        index. Notice that this is the same list as for the relativistic</div><div class="line"><a name="l01492"></a><span class="lineno"> 1492</span>&#160;        BW, just a different order.</div><div class="line"><a name="l01493"></a><span class="lineno"> 1493</span>&#160;</div><div class="line"><a name="l01494"></a><span class="lineno"> 1494</span>&#160;    -   Nonresonant component (ie, constant across the Dalitz plot):</div><div class="line"><a name="l01495"></a><span class="lineno"> 1495</span>&#160;        Nothing additional.</div><div class="line"><a name="l01496"></a><span class="lineno"> 1496</span>&#160;</div><div class="line"><a name="l01497"></a><span class="lineno"> 1497</span>&#160;    -   Gaussian: Mean and width of the Gaussian, cyclic index. Notice</div><div class="line"><a name="l01498"></a><span class="lineno"> 1498</span>&#160;        that the Gaussian takes the mass \f$m_{12,13,23}\f$ as its argument,</div><div class="line"><a name="l01499"></a><span class="lineno"> 1499</span>&#160;        not the squared mass \f$m^2_{12,13,23}\f$ like the other</div><div class="line"><a name="l01500"></a><span class="lineno"> 1500</span>&#160;        parametrisations.</div><div class="line"><a name="l01501"></a><span class="lineno"> 1501</span>&#160;</div><div class="line"><a name="l01502"></a><span class="lineno"> 1502</span>&#160;-   `TddpPdf`: If the Gaussian is a potato, this is a five-course</div><div class="line"><a name="l01503"></a><span class="lineno"> 1503</span>&#160;    banquet dinner involving entire roasted animals stuffed with other</div><div class="line"><a name="l01504"></a><span class="lineno"> 1504</span>&#160;    animals, large dance troupes performing between the courses, an</div><div class="line"><a name="l01505"></a><span class="lineno"> 1505</span>&#160;    orchestra playing in the background, and lengthy speeches. There</div><div class="line"><a name="l01506"></a><span class="lineno"> 1506</span>&#160;    will not be a vegetarian option. Without going too deeply into the</div><div class="line"><a name="l01507"></a><span class="lineno"> 1507</span>&#160;    physics, the function models a decay, eg \f$D^0\to\pi\pi\pi^0\f$, that</div><div class="line"><a name="l01508"></a><span class="lineno"> 1508</span>&#160;    can happen either directly or through a mixed path</div><div class="line"><a name="l01509"></a><span class="lineno"> 1509</span>&#160;    \f$D^0\to \overline{D^0}\to\pi\pi\pi^0\f$. (Although developed for the</div><div class="line"><a name="l01510"></a><span class="lineno"> 1510</span>&#160;    \f$\pi\pi\pi^0\f$ case, it should be useful for any decay where the</div><div class="line"><a name="l01511"></a><span class="lineno"> 1511</span>&#160;    final state is its own anti-state.) The probability of the mixing</div><div class="line"><a name="l01512"></a><span class="lineno"> 1512</span>&#160;    path depends on the decay time, and quantum-mechanically interferes</div><div class="line"><a name="l01513"></a><span class="lineno"> 1513</span>&#160;    with the direct path. Consequently the full Time-Dependent</div><div class="line"><a name="l01514"></a><span class="lineno"> 1514</span>&#160;    Dalitz-Plot (Tddp) amplitude is (suppressing the dependence on</div><div class="line"><a name="l01515"></a><span class="lineno"> 1515</span>&#160;    squared masses, for clarity): </div><div class="line"><a name="l01516"></a><span class="lineno"> 1516</span>&#160;\f{align}{</div><div class="line"><a name="l01517"></a><span class="lineno"> 1517</span>&#160;    \label{eq:fullmix}</div><div class="line"><a name="l01518"></a><span class="lineno"> 1518</span>&#160;    P(m^2_{12}, m^2_{13}, t, \sigma_t;x,y,\tau,\vec\alpha) &amp;=&amp;</div><div class="line"><a name="l01519"></a><span class="lineno"> 1519</span>&#160;    e^{-t/\tau}\Big(|A+B|^2\cosh(yt/\tau)\\</div><div class="line"><a name="l01520"></a><span class="lineno"> 1520</span>&#160;    &amp;&amp; + |A-B|^2\cos(xt/\tau)\\</div><div class="line"><a name="l01521"></a><span class="lineno"> 1521</span>&#160;    &amp;&amp; - 2\Re(AB^*)\sinh(yt/\tau)\\</div><div class="line"><a name="l01522"></a><span class="lineno"> 1522</span>&#160;    &amp;&amp; - 2\Im(AB^*)\sin(xt/\tau)\Big)</div><div class="line"><a name="l01523"></a><span class="lineno"> 1523</span>&#160;\f} where (notice the</div><div class="line"><a name="l01524"></a><span class="lineno"> 1524</span>&#160;    reversed masses in the \f$B\f$ calculation) </div><div class="line"><a name="l01525"></a><span class="lineno"> 1525</span>&#160;\f{align}{</div><div class="line"><a name="l01526"></a><span class="lineno"> 1526</span>&#160;    A &amp;=&amp; \sum\limits_i \alpha_iB_i(m^2_{12}, m^2_{13}) \\</div><div class="line"><a name="l01527"></a><span class="lineno"> 1527</span>&#160;    B &amp;=&amp; \sum\limits_i \alpha_iB_i(m^2_{13}, m^2_{12}), </div><div class="line"><a name="l01528"></a><span class="lineno"> 1528</span>&#160;\f}</div><div class="line"><a name="l01529"></a><span class="lineno"> 1529</span>&#160;    *convolved with* a time-resolution function and *multiplied by* an</div><div class="line"><a name="l01530"></a><span class="lineno"> 1530</span>&#160;    efficiency. The implementation involves a large amount of caching of</div><div class="line"><a name="l01531"></a><span class="lineno"> 1531</span>&#160;    the intermediate \f$B_i\f$ values, because these are expected to change</div><div class="line"><a name="l01532"></a><span class="lineno"> 1532</span>&#160;    slowly relative to the coefficients \f$\alpha\f$ (in many cases, not at</div><div class="line"><a name="l01533"></a><span class="lineno"> 1533</span>&#160;    all, since masses and widths are often held constant) and are</div><div class="line"><a name="l01534"></a><span class="lineno"> 1534</span>&#160;    relatively expensive to calculate.</div><div class="line"><a name="l01535"></a><span class="lineno"> 1535</span>&#160;</div><div class="line"><a name="l01536"></a><span class="lineno"> 1536</span>&#160;    The constructor takes the measured decay time \f$t\f$, error on decay</div><div class="line"><a name="l01537"></a><span class="lineno"> 1537</span>&#160;    time \f$\sigma_t\f$, squared masses \f$m^2_{12}\f$ and \f$m^2_{13}\f$, event</div><div class="line"><a name="l01538"></a><span class="lineno"> 1538</span>&#160;    number, decay information (the same class as in `DalitzPlotPdf`; it</div><div class="line"><a name="l01539"></a><span class="lineno"> 1539</span>&#160;    also holds the mixing parameters \f$x\f$ and \f$y\f$ and lifetime \f$\tau\f$),</div><div class="line"><a name="l01540"></a><span class="lineno"> 1540</span>&#160;    time-resolution function, efficiency, and optionally a mistag</div><div class="line"><a name="l01541"></a><span class="lineno"> 1541</span>&#160;    fraction. A variant constructor takes, instead of a single</div><div class="line"><a name="l01542"></a><span class="lineno"> 1542</span>&#160;    time-resolution function, a `vector` of functions and an additional</div><div class="line"><a name="l01543"></a><span class="lineno"> 1543</span>&#160;    observable \f$m_{D^0}\f$; in this case the resolution function used</div><div class="line"><a name="l01544"></a><span class="lineno"> 1544</span>&#160;    depends on which bin of \f$m_{D^0}\f$ the event is in, and the number of</div><div class="line"><a name="l01545"></a><span class="lineno"> 1545</span>&#160;    bins is taken as equal to the number of resolution functions</div><div class="line"><a name="l01546"></a><span class="lineno"> 1546</span>&#160;    supplied.</div><div class="line"><a name="l01547"></a><span class="lineno"> 1547</span>&#160;</div><div class="line"><a name="l01548"></a><span class="lineno"> 1548</span>&#160;    It is not suggested to try to use this thing from scratch. Start</div><div class="line"><a name="l01549"></a><span class="lineno"> 1549</span>&#160;    with a working example and modify it gradually.</div><div class="line"><a name="l01550"></a><span class="lineno"> 1550</span>&#160;</div><div class="line"><a name="l01551"></a><span class="lineno"> 1551</span>&#160;-   `ThreeGaussResolution`: A resolution functon consisting of a</div><div class="line"><a name="l01552"></a><span class="lineno"> 1552</span>&#160;    sum of three Gaussians, referred to as the ‘core’, ‘tail’, and</div><div class="line"><a name="l01553"></a><span class="lineno"> 1553</span>&#160;    ‘outlier’ components. The constructor takes the core and tail</div><div class="line"><a name="l01554"></a><span class="lineno"> 1554</span>&#160;    fractions (the outlier fraction is 1 minus the other two), core mean</div><div class="line"><a name="l01555"></a><span class="lineno"> 1555</span>&#160;    and width, tail mean and width, and outlier mean and width. Notice</div><div class="line"><a name="l01556"></a><span class="lineno"> 1556</span>&#160;    that this is a resolution function, so the full probability is found</div><div class="line"><a name="l01557"></a><span class="lineno"> 1557</span>&#160;    by convolving Gaussians with Equation \f$\ref{eq:fullmix}\f$, and this runs</div><div class="line"><a name="l01558"></a><span class="lineno"> 1558</span>&#160;    to a page or so of algebra involving error functions. It is beyond</div><div class="line"><a name="l01559"></a><span class="lineno"> 1559</span>&#160;    the scope of this documentation.</div><div class="line"><a name="l01560"></a><span class="lineno"> 1560</span>&#160;</div><div class="line"><a name="l01561"></a><span class="lineno"> 1561</span>&#160;-   `TrigThresholdPdf`: Intended as part of an efficiency function,</div><div class="line"><a name="l01562"></a><span class="lineno"> 1562</span>&#160;    modelling a gradual fall-off near the edges of phase space:</div><div class="line"><a name="l01563"></a><span class="lineno"> 1563</span>&#160;    </div><div class="line"><a name="l01564"></a><span class="lineno"> 1564</span>&#160;\f{align}{</div><div class="line"><a name="l01565"></a><span class="lineno"> 1565</span>&#160;    P(x;a,b,t) &amp;=&amp; \left\{\begin{matrix}</div><div class="line"><a name="l01566"></a><span class="lineno"> 1566</span>&#160;    1 &amp; d &gt; 1/2 \\</div><div class="line"><a name="l01567"></a><span class="lineno"> 1567</span>&#160;    a + (1-a) \sin(d\pi) &amp; \mathrm{otherwise}</div><div class="line"><a name="l01568"></a><span class="lineno"> 1568</span>&#160;    \end{matrix}</div><div class="line"><a name="l01569"></a><span class="lineno"> 1569</span>&#160;    \right. </div><div class="line"><a name="l01570"></a><span class="lineno"> 1570</span>&#160;\f} where \f$d=b(x-t)\f$ or \f$d=b(t-x)\f$ depending on</div><div class="line"><a name="l01571"></a><span class="lineno"> 1571</span>&#160;    whether the function is modelling a lower or upper threshold. The</div><div class="line"><a name="l01572"></a><span class="lineno"> 1572</span>&#160;    constructor takes the observable \f$x\f$ (which will be either</div><div class="line"><a name="l01573"></a><span class="lineno"> 1573</span>&#160;    \f$m^2_{12}\f$ or \f$m^2_{13}\f$), threshold value \f$t\f$, trig constant \f$b\f$,</div><div class="line"><a name="l01574"></a><span class="lineno"> 1574</span>&#160;    linear constant \f$a\f$, and a boolean which if true indicates an upper</div><div class="line"><a name="l01575"></a><span class="lineno"> 1575</span>&#160;    threshold. A variant constructor, for modelling a threshold in the</div><div class="line"><a name="l01576"></a><span class="lineno"> 1576</span>&#160;    “third” Dalitz-plot dimension \f$m^2_{23}\f$, takes both \f$m^2_{12}\f$ and</div><div class="line"><a name="l01577"></a><span class="lineno"> 1577</span>&#160;    \f$m^2_{13}\f$, and an additional mass constant \f$m\f$; it then forms</div><div class="line"><a name="l01578"></a><span class="lineno"> 1578</span>&#160;    \f$x = m - m^2_{12} - m^2_{13}\f$, and otherwise does the same</div><div class="line"><a name="l01579"></a><span class="lineno"> 1579</span>&#160;    calculation.</div><div class="line"><a name="l01580"></a><span class="lineno"> 1580</span>&#160;</div><div class="line"><a name="l01581"></a><span class="lineno"> 1581</span>&#160;-   `TruthResolution`: The simplest possible resolution function, a</div><div class="line"><a name="l01582"></a><span class="lineno"> 1582</span>&#160;    simple delta spike at zero - i.e., time is always measured</div><div class="line"><a name="l01583"></a><span class="lineno"> 1583</span>&#160;    perfectly. The constructor takes no arguments at all!</div><div class="line"><a name="l01584"></a><span class="lineno"> 1584</span>&#160;</div><div class="line"><a name="l01585"></a><span class="lineno"> 1585</span>&#160;\anchor footnote1 1: Named in homage to RooFit, with the ‘G’ standing for ‘GPU’.</div><div class="line"><a name="l01586"></a><span class="lineno"> 1586</span>&#160;</div><div class="line"><a name="l01587"></a><span class="lineno"> 1587</span>&#160;\anchor footnote2 2: Although, if they are *Buddhist* masters, they don’t even though</div><div class="line"><a name="l01588"></a><span class="lineno"> 1588</span>&#160;    they can, since they have transcended desire - and suffering with</div><div class="line"><a name="l01589"></a><span class="lineno"> 1589</span>&#160;    it.</div><div class="line"><a name="l01590"></a><span class="lineno"> 1590</span>&#160;</div><div class="line"><a name="l01591"></a><span class="lineno"> 1591</span>&#160;\anchor footnote3 3: For historical reasons, MINUIT always minimises rather than</div><div class="line"><a name="l01592"></a><span class="lineno"> 1592</span>&#160;    maximising.</div><div class="line"><a name="l01593"></a><span class="lineno"> 1593</span>&#160;</div><div class="line"><a name="l01594"></a><span class="lineno"> 1594</span>&#160;\anchor footnote4 4: You might ask, why not copy the function directly? The reason is</div><div class="line"><a name="l01595"></a><span class="lineno"> 1595</span>&#160;    that `cudaMemcpy` doesn’t like to get the address of a function, but</div><div class="line"><a name="l01596"></a><span class="lineno"> 1596</span>&#160;    `nvcc` is perfectly happy to statically initialize a pointer. It’s a</div><div class="line"><a name="l01597"></a><span class="lineno"> 1597</span>&#160;    workaround, in other words.</div><div class="line"><a name="l01598"></a><span class="lineno"> 1598</span>&#160;</div><div class="line"><a name="l01599"></a><span class="lineno"> 1599</span>&#160;\anchor footnote5 5: These are, respectively, ancient FORTRAN code translated</div><div class="line"><a name="l01600"></a><span class="lineno"> 1600</span>&#160;    line-by-line into C++, almost literally by the addition of</div><div class="line"><a name="l01601"></a><span class="lineno"> 1601</span>&#160;    semicolons; someone’s obsessively-detailed object-oriented</div><div class="line"><a name="l01602"></a><span class="lineno"> 1602</span>&#160;    implementation of the same algorithm, with the same spaghetti logic</div><div class="line"><a name="l01603"></a><span class="lineno"> 1603</span>&#160;    chopped into classes instead of lines of code; and what seems to be</div><div class="line"><a name="l01604"></a><span class="lineno"> 1604</span>&#160;    intended as a common interface for a large number of possible</div><div class="line"><a name="l01605"></a><span class="lineno"> 1605</span>&#160;    fitting backends, which falls a little flat since it has only the</div><div class="line"><a name="l01606"></a><span class="lineno"> 1606</span>&#160;    MINUIT backend to talk to. You pays your money and takes your</div><div class="line"><a name="l01607"></a><span class="lineno"> 1607</span>&#160;    choice.</div><div class="line"><a name="l01608"></a><span class="lineno"> 1608</span>&#160;</div><div class="line"><a name="l01609"></a><span class="lineno"> 1609</span>&#160;\anchor footnote6 6: A global bin ranges from 0 to \f$n_1n_2\ldots n_N-1\f$ where \f$n_j\f$ is</div><div class="line"><a name="l01610"></a><span class="lineno"> 1610</span>&#160;    the number of bins in the \f$j\f$th variable and \f$N\f$ is the number of</div><div class="line"><a name="l01611"></a><span class="lineno"> 1611</span>&#160;    variables. In two dimensions, with three bins in each of \f$x\f$ and</div><div class="line"><a name="l01612"></a><span class="lineno"> 1612</span>&#160;    \f$y\f$, the global bin is given by \f$3b_y+b_x\f$, where \f$b_{x,y}\f$ is the</div><div class="line"><a name="l01613"></a><span class="lineno"> 1613</span>&#160;    bin number in \f$x\f$ or \f$y\f$ respectively, as shown here:</div><div class="line"><a name="l01614"></a><span class="lineno"> 1614</span>&#160;    </div><div class="line"><a name="l01615"></a><span class="lineno"> 1615</span>&#160;\f[</div><div class="line"><a name="l01616"></a><span class="lineno"> 1616</span>&#160;\begin{array}{l|ccc}</div><div class="line"><a name="l01617"></a><span class="lineno"> 1617</span>&#160;    2 &amp; 6 &amp; 7 &amp; 8 \\</div><div class="line"><a name="l01618"></a><span class="lineno"> 1618</span>&#160;    1 &amp; 3 &amp; 4 &amp; 5 \\</div><div class="line"><a name="l01619"></a><span class="lineno"> 1619</span>&#160;    0 &amp; 0 &amp; 1 &amp; 2 \\</div><div class="line"><a name="l01620"></a><span class="lineno"> 1620</span>&#160;    \hline</div><div class="line"><a name="l01621"></a><span class="lineno"> 1621</span>&#160;      &amp; 0 &amp; 1 &amp; 2 </div><div class="line"><a name="l01622"></a><span class="lineno"> 1622</span>&#160;\end{array}</div><div class="line"><a name="l01623"></a><span class="lineno"> 1623</span>&#160;\f]</div><div class="line"><a name="l01624"></a><span class="lineno"> 1624</span>&#160; where the leftmost column and bottom row indicate the</div><div class="line"><a name="l01625"></a><span class="lineno"> 1625</span>&#160;    \f$y\f$ and \f$x\f$ bin number.</div><div class="line"><a name="l01626"></a><span class="lineno"> 1626</span>&#160;</div><div class="line"><a name="l01627"></a><span class="lineno"> 1627</span>&#160;\anchor footnote7 7: That is, `__shared__` for the default CUDA target.</div><div class="line"><a name="l01628"></a><span class="lineno"> 1628</span>&#160;</div><div class="line"><a name="l01629"></a><span class="lineno"> 1629</span>&#160;\anchor footnote8 8: This is why `functorConstants[0]` is reserved for that value!</div><div class="line"><a name="l01630"></a><span class="lineno"> 1630</span>&#160;</div><div class="line"><a name="l01631"></a><span class="lineno"> 1631</span>&#160;\anchor footnote9 9: On the grounds that ten dimensions should be enough for anyone!</div><div class="line"><a name="l01632"></a><span class="lineno"> 1632</span>&#160;</div><div class="line"><a name="l01633"></a><span class="lineno"> 1633</span>&#160;\anchor footnote10 10: Oops, there’s that potato after all. It’s a contrived example.</div><div class="line"><a name="l01634"></a><span class="lineno"> 1634</span>&#160;</div><div class="line"><a name="l01635"></a><span class="lineno"> 1635</span>&#160;\anchor footnote11 11: If this seems complicated, spare a thought for the hapless</div><div class="line"><a name="l01636"></a><span class="lineno"> 1636</span>&#160;ergrad who had to code the original CPU version.</div><div class="line"><a name="l01637"></a><span class="lineno"> 1637</span>&#160;</div><div class="line"><a name="l01638"></a><span class="lineno"> 1638</span>&#160;\anchor footnote12 12: Although being honest, just supporting the special cases of one</div><div class="line"><a name="l01639"></a><span class="lineno"> 1639</span>&#160;    and two would likely have sufficed.</div></div><!-- fragment --></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Apr 11 2018 19:28:00 for GooFit by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
